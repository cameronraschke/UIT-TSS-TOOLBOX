#!/bin/bash
SSD_REGEX='sd.*'
NVME_REGEX='nvme.*'
SCSI_REGEX='hd.*'
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
BLUE=$(tput setaf 4)
BOLD=$(tput bold)
DIM=$(tput dim)
RESET=$(tput sgr0)
cloneElapsed="0"
shredElapsed="0"

etherAddr=$(for i in $(ip addr | awk '/state UP/ {print $2}' | sed 's/://g'); do cat /sys/class/net/${i}/address; done)


while IFS=$'\t' read sql; do
	if [[ -z $shrlTag ]]; then
		shrlTag=( "$sql" )
	else
		shrlTag+=( "$sql" )
	fi
done < <(mysql --user="shrl" --password="UHouston!" --database="shrl" --host="10.0.0.1" -BNr \
		--execute="SELECT DISTINCT tagnumber FROM locations;" 2>/dev/null)

while IFS=$'\t' read sql; do
	if [[ -z $techCommTag ]]; then
		techCommTag=( "$sql" )
	else
		techCommTag+=( "$sql" )
	fi
done < <(mysql --user="laptops" --password="UHouston!" --database="laptopDB" --host="10.0.0.1" -BNr \
		--execute="SELECT DISTINCT tagnumber FROM locations;" 2>/dev/null)


tOneSerialNumber=$(dmidecode --string system-serial-number)


DATE=$(date --iso)
sambaPath="images"


tput reset



function hardwareData {
	### DMI Data
	#t0 = BIOS
	#t1 = system
	#t2 = Base Board/Motherboard
	#t3 = Chassis
	#t4 = Processor
	#t22 = Battery
	#t32 = Boot Status
	tZeroVendor=$(dmidecode --string bios-vendor)
		echo "general|bios_vendor|${tZeroVendor}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tZeroBiosVersion=$(dmidecode --string bios-version)
		echo "general|bios_version|${tZeroBiosVersion}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tZeroBiosReleaseDate=$(dmidecode --string bios-release-date)
		echo "general|bios_date|${tZeroBiosReleaseDate}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tZeroBiosRevision=$(dmidecode --string bios-revision)
		echo "general|bios_revision|${tZeroBiosRevision}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tZeroFirmwareRevision=$(dmidecode --string firmware-revision)
		echo "general|bios_firmware|${tZeroFirmwareRevision}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tOneManufacturer=$(dmidecode --string system-manufacturer)
		echo "general|system_manufacturer|${tOneManufacturer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tOneProductName=$(dmidecode --string system-product-name)
		echo "general|system_productname|${tOneProductName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tOneSerialNumber=$(dmidecode --string system-serial-number)
		echo "general|system_serial|${tOneSerialNumber}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tOneUUID=$(dmidecode --string system-uuid)
		echo "general|system_uuid|${tOneUUID}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tOneSKU=$(dmidecode --string system-sku-number)
		echo "general|system_sku|${tOneSKU}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tOneFamily=$(dmidecode --string system-family)
		echo "general|system_family|${tOneFamily}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tTwoManufacturer=$(dmidecode --string baseboard-manufacturer)
		echo "general|motherboard_manufacturer|${tTwoManufacturer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tTwoSerialNumber=$(dmidecode --string baseboard-serial-number)
		echo "general|motherboard_serial|${tTwoSerialNumber}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tThreeManufacturer=$(dmidecode --string chassis-manufacturer)
		echo "general|chassis_manufacturer|${tThreeManufacturer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tThreeType=$(dmidecode --string chassis-type)
		echo "general|chassis_type|${tThreeType}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tThreeSerialNumber=$(dmidecode --string chassis-serial-number)
		echo "general|chassis_serial|${tThreeSerialNumber}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tThreeAssetTag=$(dmidecode --string chassis-asset-tag)
		echo "general|chassis_tag|${tThreeAssetTag}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tThreePowerSupplyState=$(dmidecode -t3 | grep 'Power Supply State' | sed 's/Power Supply State: //g')
		echo "general|chassis_psu|${tThreePowerSupplyState}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourFamily=$(dmidecode --string processor-family)
		echo "general|cpu_family|${tFourFamily}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourManufacturer=$(dmidecode --string processor-manufacturer)
		echo "general|cpu_manufacturer|${tFourManufacturer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourID=$(dmidecode -t4 | grep 'ID' | sed 's/ID: //g' | sed 's/^[[:space:]]*//g')
		echo "general|cpu_id|${tFourID}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourVersion=$(dmidecode --string processor-version)
		echo "general|cpu_version|${tFourVersion}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourVoltage=$(dmidecode -t4 | grep 'Voltage' | sed 's/Voltage: //g' | sed 's/^[[:space:]]*//g')
		echo "general|cpu_voltage|${tFourVoltage}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourMaxSpeed=$(dmidecode -t4 | grep 'Max Speed' | sed 's/Max Speed: //g' | sed 's/^[[:space:]]*//g')
		echo "general|cpu_maxspeed|${tFourMaxSpeed}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourCurrentSpeed=$(dmidecode --string processor-frequency)
		echo "general|cpu_currentspeed|${tFourCurrentSpeed}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourCoreCount=$(dmidecode -t4 | grep 'Core Count' | sed 's/Core Count: //g' | sed 's/^[[:space:]]*//g')
		echo "general|cpu_cores|${tFourCoreCount}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tFourThreadCount=$(dmidecode -t4 | grep 'Thread Count' | sed 's/Thread Count: //g' | sed 's/^[[:space:]]*//g')
		echo "general|cpu_threads|${tFourThreadCount}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tTwentyTwoManufacturer=$(dmidecode -t22 | grep 'Manufacturer' | sed 's/Manufacturer: //g' | sed 's/^[[:space:]]*//g')
		echo "general|battery_manufacturer|${tTwentyTwoManufacturer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tTwentyTwoName=$(dmidecode -t22 | grep 'Name' | sed 's/Name: //g' | sed 's/^[[:space:]]*//g')
		echo "general|battery_name|${tTwentyTwoName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tTwentyTwoCapacity=$(dmidecode -t22 | grep 'Design Capacity' | sed 's/Design Capacity: //g' | sed 's/^[[:space:]]*//g')
		echo "general|battery_capacity|${tTwentyTwoCapacity}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tTwentyTwoVoltage=$(dmidecode -t22 | grep 'Design Voltage' | sed 's/Design Voltage: //g' | sed 's/^[[:space:]]*//g')
		echo "general|battery_voltage|${tTwentyTwoVoltage}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tTwentyTwoSerialNumber=$(dmidecode -t22 | grep 'SBDS Serial Number' | sed 's/SBDS Serial Number: //g' | sed 's/^[[:space:]]*//g')
		echo "general|battery_serial|${tTwentyTwoSerialNumber}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tTwentyTwoManufactureDate=$(dmidecode -t22 | grep 'SBDS Manufacture Date' | sed 's/SBDS Manufacture Date: //g' | sed 's/^[[:space:]]*//g')
		echo "general|battery_manufacturedate|${tTwentyTwoManufactureDate}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	tThirtyTwoBootStatus=$(dmidecode -t32 | grep 'Status' | sed 's/Status: //g' | sed 's/^[[:space:]]*//g')
		echo "general|boot_errors|${tThirtyTwoBootStatus}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse

	###Disk Data
	diskModel=$(cat /root/smartctl-data | grep '^Model Number: ' | sed 's/Model Number: *//g')
		echo "disk|disk_model|${UUID}|${diskModel}" | /var/lib/UIT-TSS-TOOLBOX/parse
	diskSerial=$(cat /root/smartctl-data | grep '^Serial Number: ' | sed 's/Serial Number: *//g')
		echo "disk|disk_serial|${UUID}|${diskSerial}" | /var/lib/UIT-TSS-TOOLBOX/parse
	diskFirmware=$(cat /root/smartctl-data | grep '^Firmware Version: ' | sed 's/Firmware Version: *//g')
		echo "disk|disk_firmware|${UUID}|${diskFirmware}" | /var/lib/UIT-TSS-TOOLBOX/parse
	diskHealth=$(cat /root/smartctl-data | grep '^SMART overall-health self-assessment test result: ' | sed 's/SMART overall-health self-assessment test result: *//g')
		echo "disk|disk_health|${UUID}|${diskHealth}" | /var/lib/UIT-TSS-TOOLBOX/parse
	diskTemp=$(cat /root/smartctl-data | grep '^Temperature: ' | sed 's/Temperature: *//g')
		echo "disk|disk_temp|${UUID}|${diskTemp}|NULL" | /var/lib/UIT-TSS-TOOLBOX/parse
	
	diskReads=$(cat /root/smartctl-data | grep '^Data Units Read: ' | sed 's/Data Units Read: *//g' | grep -o '\[.*\]' | sed 's/\[//g' | sed 's/\]//g')
	tbVRFY=$(echo "${diskReads}" | grep -iq 'TB' &>/dev/null; echo ${PIPESTATUS[1]})
	gbVRFY=$(echo "${diskReads}" | grep -iq 'GB' &>/dev/null; echo ${PIPESTATUS[1]})
	if [[ $tbVRFY == 0 ]]; then
			diskReads=$(echo "${diskReads}" | sed 's/[^0-9\.]//g')
			echo "disk|disk_reads|${UUID}|${diskReads}|TB" | /var/lib/UIT-TSS-TOOLBOX/parse
		elif [[ $gbVRFY == 0 ]]; then
			diskReads=$(echo "$diskReads" | sed 's/[^0-9\.]//g')
			echo "disk|disk_reads|${UUID}|${diskReads}|GB" | /var/lib/UIT-TSS-TOOLBOX/parse
		else
			echo "disk|disk_reads|${UUID}||TB" | /var/lib/UIT-TSS-TOOLBOX/parse
	fi

	diskWrites=$(cat /root/smartctl-data | grep '^Data Units Written: ' | sed 's/Data Units Written: *//g' | grep -o '\[.*\]' | sed 's/\[//g' | sed 's/\]//g')
	tbVRFY=$(echo "${diskWrites}" | grep -iq 'TB' &>/dev/null; echo ${PIPESTATUS[1]})
	gbVRFY=$(echo "${diskWrites}" | grep -iq 'GB' &>/dev/null; echo ${PIPESTATUS[1]})
	if [[ $tbVRFY == 0 ]]; then
			diskWrites=$(echo "${diskWrites}" | sed 's/[^0-9\.]//g')
			echo "disk|disk_writes|${UUID}|${diskWrites}|TB" | /var/lib/UIT-TSS-TOOLBOX/parse
		elif [[ $gbVRFY == 0 ]]; then
			diskWrites=$(echo "$diskWrites" | sed 's/[^0-9\.]//g')
			echo "disk|disk_writes|${UUID}|${diskWrites}|GB" | /var/lib/UIT-TSS-TOOLBOX/parse
		else
			echo "disk|disk_writes|${UUID}||TB" | /var/lib/UIT-TSS-TOOLBOX/parse
	fi

	###Battery Data
	batChargeNow=$(cat /sys/class/power_supply/BAT0/charge_full)
	batChargeFactory=$(cat /sys/class/power_supply/BAT0/charge_full_design)
	batHealthPCNT=$(( batChargeNow * 100 / batChargeFactory ))
		echo "battery|battery_health|${UUID}|${batHealthPCNT}" | /var/lib/UIT-TSS-TOOLBOX/parse
	batAlarmBool=$(cat /sys/class/power_supply/BAT0/alarm)
		echo "battery|battery_alarm|${UUID}|${batAlarmBool}" | /var/lib/UIT-TSS-TOOLBOX/parse
	batChargeCycles=$(cat /sys/class/power_supply/BAT0/cycle_count)
		echo "battery|battery_charge_cycles|${UUID}|${batChargeCycles}" | /var/lib/UIT-TSS-TOOLBOX/parse

	###Memory Data
	memSerial=$(dmidecode --type memory | grep Serial | sed 's/Serial Number: //g' | sed 's/[[:space:]]//g' | perl -p -e 's/\n/ /')
		echo "general|ram_serial|${memSerial}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse

	###Boot Times
	bootTime=$(systemd-analyze | grep -oP '[0-9]+[0-9.]*' | head -n 1)
		echo "general|boot_time|${bootTime}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
}



function enterTag {
	local regex="[[:digit:]]{6}"
	tput reset
	echo ""

	echo "checktag|${tOneSerialNumber}" | /var/lib/UIT-TSS-TOOLBOX/parse
	while [[ ! -f /tmp/tagnumber.uit ]]; do sleep 0.1; done
	tagNum=$(cat /tmp/tagnumber.uit 2>/dev/null)
	if [[ $tagNum != "" ]]; then

		if [[ ${shrlTag[*]} =~ $tagNum ]]; then
			UUID=$(echo -n "shrl-"; cat /proc/sys/kernel/random/uuid)
		elif [[ ${techCommTag[*]} =~ $tagNum ]]; then
			UUID=$(echo -n "techComm-"; cat /proc/sys/kernel/random/uuid)
		else
			UUID=$(cat /proc/sys/kernel/random/uuid)
		fi

		echo "init|${UUID}|${tagNum}|${etherAddr}" | /var/lib/UIT-TSS-TOOLBOX/parse
		echo "general|tagnumber|${tagNum}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		echo "location|begin|${tagNum}|${tOneSerialNumber}" | /var/lib/UIT-TSS-TOOLBOX/parse
		return
	else
		read -p "${BOLD}Please enter the ${BLUE}6-digit tag number${RESET} ${BOLD}followed by ${GREEN}Enter${RESET}${BOLD}:${RESET} " tagNum
		echo ""
		echo "${BOLD}Please select the ${BLUE}department${RESET}${BOLD}:${RESET} "
		echo "   ${BOLD}${GREEN}[1]${RESET} ${BOLD}TechCommons${RESET}"
		echo "   ${BOLD}${GREEN}[2]${RESET} ${BOLD}SHRL${RESET}"
		echo ""
		read -n 1 -p "${BOLD}Please enter [1,2]:${RESET} " department
		echo "location|begin|${tagNum}|${tOneSerialNumber}|${location}|${status}|${problem}|${department}" | /var/lib/UIT-TSS-TOOLBOX/parse
		ssh cameron@mickey.uit "echo $tagNum | uit-sql-refresh-client 2>/dev/null"
		enterTag
	fi
}



function info {
	if [[ $ACTION != "" ]]; then
		echo "The selected mode is ${BOLD}${ACTION}${RESET}"
	fi

	if [[ $CLIENTDISK != "" ]]; then
		echo "The selected disk is ${BOLD}${CLIENTDISK}${RESET}"
	fi

	if [[ $cloneMode != "" ]]; then
		echo "The selected clone mode is ${BOLD}${cloneMode}${RESET}"
	fi
	if [[ $cloneImgName != "" ]]; then
		echo "The selected image is ${BOLD}${cloneImgName}${RESET}"
	fi

	echo ""
}



function footer {
	lines=$(tput lines)
	tput reset
	tput cup $(( lines - 3 ))
	echo "Tagnumber: ${tagNum}, System Serial Number: ${tOneSerialNumber}"
	echo ""
	echo "${DIM}UIT-TSS-TOOLBOX by ${RESET}Cameron Raschke${DIM} (caraschke@uh.edu). ${RESET}${RED}Go coogs!!${RESET}"
	tput cup 0 0
	echo ""
	info
}



function logo {
	tput reset
	footer
	echo -n "UIT-TSS-TOOLBOX by ${BOLD}Cameron Raschke${RESET} ${DIM}(caraschke@uh.edu)${RESET}. "
	echo "${BOLD}${RED}Go coogs!!${RESET}"
	echo ""
	tput bold
	tput setaf 1
	echo "| |    | |  | |     | |"
	echo "| |    | |  | |_____| |"
	echo "| |    | |  | |_____| |"
	echo "| |____| |  | |     | |"
	echo "\________/  | |     | |"
	tput sgr0
	echo ""
	echo "------------------------------"
}



function manualClient {
	logo
	echo "${BOLD}-General best practices${RESET} "
	echo "   * Sanitize laptops with cleaner before imaging them."
	echo "   * Reset BIOS to default/factory settings before imaging."
	echo "${BOLD}-Dells${RESET} "
	echo "   * Make sure SATA mode is in AHCI mode and not RAID mode."
	echo "      * This is usually under \"System Configuration\" or \"Storage\" in BIOS."
	echo ""
	echo "${BOLD}Please remove the thumb drive and select one of the following options:${RESET} "
	echo "   ${BOLD}${GREEN}[1]${RESET} ${BOLD}Clone ${DIM}(server -> laptop)${RESET} ${BOLD}an HP laptop${RESET}"
	echo "   ${BOLD}${GREEN}[2]${RESET} ${BOLD}Clone ${DIM}(server -> laptop)${RESET} ${BOLD}a SMALL Dell laptop${RESET}"
	echo "   ${BOLD}${GREEN}[3]${RESET} ${BOLD}Clone ${DIM}(server -> laptop)${RESET} ${BOLD}a BIG Dell laptop${RESET}"
	echo "   ${BOLD}${GREEN}[4]${RESET} ${BOLD}Simple erase NVME${RESET} ${DIM}(nvme0/nvme0n1)${RESET}"
	echo "   ${BOLD}${GREEN}[5]${RESET} ${BOLD}Simple erase SATA${RESET} ${DIM}(sda)${RESET}"
	echo "   ${BOLD}${GREEN}[9]${RESET} ${BOLD}Other options${RESET} ${DIM}(advanced)${RESET}"
	echo "   ${BOLD}${GREEN}[0]${RESET} ${BOLD}Associate Hardware Data${RESET}"
	read -n 1 -p "${BOLD}Please enter [0-9]:${RESET} " mainMenuOpt
}



function autodetectClient {
	echo -n "${tOneManufacturer}" > /tmp/manufacturer.uit
	echo -n "${tThreeType}" > /tmp/chassis.uit
	for i in $(lsblk --nodeps --noheadings -o NAME --exclude 1,2,7,11); do echo $i > /tmp/disk.uit; done
	autodetectDisk=$(cat /tmp/disk.uit)

	while [[ ! -f /tmp/manufacturer.uit || ! -f /tmp/chassis.uit || ! -f /tmp/disk.uit ]]; do
		sleep 0.1
	done

	if grep -i 'dell' /tmp/manufacturer.uit; then
		systemManufacturer="dell"
		elif grep -i 'hp' /tmp/manufacturer.uit; then
			systemManufacturer="hp"
		else
			systemManufacturer="unknown"
	fi

	if grep -i 'notebook' /tmp/chassis.uit; then
		chassisType="notebook"
		elif grep -i 'desktop' /tmp/chassis.uit; then
			chassisType="desktop"
		else
			chassisType="unknown"
	fi

	if grep -i 'nvme' /tmp/disk.uit; then
		diskType="nvme"
		elif grep -i 'sd' /tmp/disk.uit; then
			diskType="sata"
		else
			diskType="unknown"
	fi

	logo
	echo "${BOLD}${BLUE}Autodetect mode${RESET}${BOLD} will destroy all data on this laptop and image it."
	echo ""
	echo "------------------------------"
	echo "${BOLD}Select mode:${RESET}"
	echo "   ${BOLD}${GREEN}[1]${RESET} ${BOLD}Autodetect${RESET}"
	echo "   ${BOLD}${GREEN}[2]${RESET} ${BOLD}Manual${RESET}"
	read -n 1 -p "${BOLD}Enter [1,2]:${RESET} " autodetectMenu

	if [[ $autodetectMenu == "1" ]]; then
		if [[ $systemManufacturer == "hp" && $chassisType == "notebook" && $diskType == "nvme" && $tOneProductName == "HP ProBook 450 G6" ]]; then
			mainMenuOpt="1"
			elif [[ $systemManufacturer == "dell" && $chassisType == "notebook" && $diskType == "nvme" && $tOneProductName == "Latitude 7400" ]]; then
				mainMenuOpt="2"
			elif [[ $systemManufacturer == "dell" && $chassisType == "notebook" && $diskType == "sata" && $tOneProductName != "Latitude 7400" ]]; then
				mainMenuOpt="5"
			else
				echo ""
				echo "${BOLD}${RED}Not enough info for autodetect.${RESET}"
				sleep 0.5
				manualClient
		fi
		echo ""
		echo "------------------------------"
		echo "${BOLD}Is this information corect?${RESET}"
		echo ""
		echo "${BOLD}${BLUE}System Manufacturer${RESET}${BOLD}: ${systemManufacturer}${RESET}"
		echo "${BOLD}${BLUE}Chassis Type${RESET}${BOLD}: ${chassisType}${RESET}"
		echo "${BOLD}${BLUE}Disk type${RESET}${BOLD}: ${autodetectDisk}${RESET}"
		echo ""
		echo "${BOLD}${GREEN}[1]${RESET} ${BOLD}Yes, it is correct${RESET}"
		echo "${BOLD}${GREEN}[2]${RESET} ${BOLD}No, start over${RESET}"
		read -n 1 -p "${BOLD}Please enter [1,2]:${RESET} " autoSelectConf
		if [[ $autoSelectConf == "1" ]]; then
				return
			else
				autodetectClient
		fi
		else
			manualClient
	fi
}



function intro {
	tput reset
	autodetectClient
	tput reset
	return
}



function powerWarning {
	footer
	echo "${BOLD}${RED}*** WARNING ***${RESET}"
	echo "${BOLD}It is highly recommended to put the computer into hibernate mode. This takes less than 5 seconds.${RESET}"
	echo "${BOLD}Remember to wake up the system after it hibernates.${RESET}"
	echo "${BOLD}${RED}*** WARNING ***${RESET}"
	echo ""
	echo "${BOLD}${GREEN}[1]${RESET} ${BOLD}Hibernate (recommended)${RESET}"
	echo "${BOLD}${GREEN}[2]${RESET} ${BOLD}Skip hibernate${RESET}"
	read -n 1 -p  "${BOLD}Please enter [1-2]:${RESET} " restartBool
	if [[ $restartBool == "1" ]]; then
		tput reset
		echo "general|reboot|yes|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		echo -n mem > /sys/power/state
		tput reset
	elif [[ $restartBool == "2" ]]; then
		tput reset
		echo "${BOLD}${RED}*** WARNING ***${RESET}"
		echo "${BOLD}It is dangerous to skip this step.${RESET}"
		echo "${BOLD}${RED}*** WARNING ***${RESET}"
		echo ""
		read -p "Press ${BOLD}${RED}Enter${RESET} to skip this step and NOT hibernate ${RED}(DANGEROUS)${RESET}.... "
		tput reset
	else
		powerWarning
	fi
}



function appSelect {
	footer
	echo "${BOLD}Please select an ${BLUE}action${RESET}${BOLD}:${RESET} "
	echo ""
	echo "   ${BOLD}${GREEN}[1]${RESET} ${BOLD}erase and clone${RESET}"
	echo "   ${BOLD}${GREEN}[2]${RESET} ${BOLD}only erase (advanced)${RESET}"
	echo "   ${BOLD}${GREEN}[3]${RESET} ${BOLD}only clone${RESET}"
	read -n 1 -p "${BOLD}Please enter [1-3]:${RESET} " APPSELECT
	if [[ $APPSELECT == "1" ]]; then
		APPSELECT="EC"
		ACTION="erase and clone"
		echo "general|action|${ACTION}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		powerWarning
	elif [[ $APPSELECT == "2" ]]; then
		APPSELECT="E"
		ACTION="erase"
		echo "general|action|${ACTION}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		powerWarning
	elif [[ $APPSELECT == "3" ]]; then
		APPSELECT="C"
		ACTION="clone"
		echo "general|action|${ACTION}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	else
		echo ""
		echo "${BOLD}${RED}Please enter a valid number [1-3].${RESET}"
		sleep 0.5
		appSelect
	fi
}



function basicEraseMode_Shred {
	shredMode='autodetect'
	RMODE='Autodetect'
	if [[ $shredMode == 'autodetect' ]]; then
		if [[ $CLIENTDISK =~ $SSD_REGEX ]]; then
			zeroQuick="1"
			shredMode='zero'
			RMODE='Zero Mode'
		elif [[ $CLIENTDISK =~ $NVME_REGEX ]]; then
			shredMode='nist'
			RMODE='NIST 800-88r1 Mode'
		else
			shredMode='zero'
			RMODE='Zero Mode'
		fi
	fi
	echo "general|erase_mode|${RMODE}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
}



function advEraseMode_Shred {
	tput reset
	setfont /usr/share/consolefonts/Lat7-Terminus28x14.psf.gz
	footer

	echo ""
	echo "${BOLD}${GREEN}[1]${RESET} ${BOLD}Autodetect${RESET} (Default)
	-Best trade off between security and speed. Autodetects the best mode for your disk."

	echo ""
	echo "${BOLD}${GREEN}[2]${RESET} ${BOLD}NIST 800-88r1${RESET}
	-Fastest for NVME."

	echo ""
	echo "${BOLD}${GREEN}[3]${RESET} ${BOLD}Zero Mode + Quick Verify${RESET}
	-One pass of zeroes, quick verification step."
	
	echo ""
	echo "${BOLD}${GREEN}[4]${RESET} ${BOLD}DOD 5220.22-M/NCSC-TG-025/AFSSI-5020/HMG IS5${RESET}
	-Writes a pass of zeroes, then ones, then a random bit. Verifies each step."

	echo ""
	echo "${BOLD}${GREEN}[5]${RESET} ${BOLD}RCMP TSSIT OPS-II/VSITR${RESET}
	-Alternates between 0's and 1's 6 times. 7th pass writes and verifies a random bit."

	echo ""
	echo "${BOLD}${GREEN}[6]${RESET} ${BOLD}Schneier${RESET}
	-A pass of 1's then a pass of 0's. Five passes of a random pattern of characters."

	echo ""
	echo "${BOLD}${GREEN}[7]${RESET} ${BOLD}Gutmann${RESET}
	-Four random character passes, 27 predefined pattern passes, four more random character passes."
	
	echo ""
	echo "${BOLD}${GREEN}[8]${RESET} ${BOLD}Verify Only${RESET}
	-Does not write data, choose character/pattern to verify."

	echo ""
	echo "${BOLD}${GREEN}[9]${RESET} ${BOLD}Unlock${RESET}
	-Unlocks disks previously locked by this program."

	echo ""
	read -n 1 -p "${BOLD}Please select an option [0-9]:${RESET} " MODESELECT
	echo ""

	case $MODESELECT in
	1)
	shredMode='autodetect'
	RMODE='Autodetect'
	basicEraseMode_Shred
	;;
	2)
	shredMode='nist'
	RMODE='NIST 800-88r1 Mode'
	;;
	3)
	shredMode='zero'
	RMODE='Zero Mode'
	;;
	4)
	shredMode='dod'
	RMODE='DOD 5220.22-M/NCSC-TG-025/AFSSI-5020/HMG IS5 Mode'
	;;
	5)
	shredMode='rcmp'
	RMODE='RCMP TSSIT OPS-II/VSITR Mode'
	;;
	6)
	shredMode='schneier'
	RMODE='Schneier Mode'
	;;
	7)
	shredMode='gutmann'
	RMODE='Gutmann Mode'
	;;
	8)
	shredMode='verify'
	RMODE='Verify Mode'
	;;
	9)
	shredMode='unlock'
	RMODE='Unlock Mode'
	;;
	*)
	modeselect
	;;
	esac

	tput reset
	setfont /usr/share/consolefonts/Lat7-Terminus32x16.psf.gz
	echo ""
	read -p "Are you sure you want to use ${BOLD}${BLUE}${RMODE}${RESET} on ${BOLD}${BLUE}${CLIENTDISK}${RESET}? Press ${BOLD}${GREEN}Enter${RESET} to continue...${RESET} "

	echo "general|erase_mode|${RMODE}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
}



function diskSelect {
	diskList=$(lsblk --nodeps --noheadings -o NAME,SIZE --exclude 1,2,7,11)
	diskNames=$(echo "${diskList}" | awk '{print $1}')
	CLIENTDISK=""
	diskCount="0"
	local diskConfirm=""
	local a="0"
	local n="0"
	local diskArr=()
	footer

	for i in ${diskNames}; do
		diskCount=$(( diskCount + 1 ))
		diskArr+=( "$i" )
	done

	if [[ $diskCount == "1" ]]; then
		for i in ${!diskArr[@]}; do
			CLIENTDISK=${diskArr[$i]}
		done
		echo "The disk ${BOLD}${BLUE}${CLIENTDISK}${RESET} has been automatically selected because it is the only detected disk."
		read -n 1 -p "Press ${BOLD}${GREEN}[1]${RESET} to confirm:${RESET} " diskConfirm
		if [[ $diskConfirm != "1" ]]; then
			echo "${BOLD}${RED}Reselecting disk.${RESET}"
			sleep 0.5
			diskSelect
		fi
	else
		echo "Which disk do you want to ${BOLD}${BLUE}${ACTION}${RESET}?"
		while read -r line; do
			a=$(( a + 1 ))
			echo "${BOLD}${GREEN}[${a}]${RESET} $line"
		done < <(echo "${BOLD}${diskList}${RESET}")

		echo ""
		read -n 1 -p "${BOLD}Please select [1-$a]:${RESET} " CLIENTDISK
		for i in ${!diskArr[@]}; do
			n=$(( $n + 1 ))
			if [[ $n == $CLIENTDISK ]]; then
				CLIENTDISK=${diskArr[$i]}
			fi
		done
		echo ""
		echo ""
	fi
	
	if [[ $CLIENTDISK =~ ${NVME_REGEX} || $CLIENTDISK =~ ${SSD_REGEX} ]]; then
		echo "general|disk|${CLIENTDISK}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	else
	    echo ""
	    echo "${BOLD}${RED}Invalid disk regex check.${RESET}"
		sleep 0.5
	    diskSelect
	fi	
}



function randBit_Shred {
	RANDBIT=$(cat /dev/urandom | xxd -plain | head -1 | cut -c 1)
}



function randPattern_Shred {
	RANDPATTERN=$(cat /dev/urandom | xxd -plain | head -1 | cut -c 8)
}



function writeDisk_Shred {
	SECTIONS='1000'
	DIVPERSEC='2'
	BS='1M'
	DISKSIZEMB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 ))
	DISKSIZEGB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 / 1000 ))
	echo "general|disksizegb|${DISKSIZEGB}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	SECTIONSIZEMB=$(( DISKSIZEMB / SECTIONS ))
	COUNT=$(( SECTIONSIZEMB / 100 * PCNTOFSECTOR / 2 ))
	PROCFAIL='0'
	local a='0'
	local i='0'

	if [[ -z $CHAR ]]; then
		CHAR='0'
	fi

	if [[ -z $WMODE ]]; then
		WMODE='zero'
	fi

	if [[ -z $PCNTOFSECTOR ]]; then
		PCNTOFSECTOR='100'
	fi
	
	if [[ $WMODE == "zero" ]]; then
		SOURCE='cat /dev/zero'
		BITS='null bits'
	fi

	if [[ $WMODE == "random" ]]; then
		SOURCE='cat /dev/urandom'
		BITS='random bits'
	fi

	if [[ $WMODE == "randBit_Shred" ]]; then
		randBit_Shred
		SOURCE="yes \"${RANDBIT}\""
		BITS="a random bit (${RANDBIT})"
	fi

	if [[ "$WMODE" == 'randPattern_Shred' ]]; then
		randPattern_Shred
		SOURCE="yes \"${RANDPATTERN}\""
		BITS="a random bit (${RANDPATTERN})"
	fi

	if [[ "$WMODE" == 'char' ]]; then
		SOURCE="yes \"${CHAR}\""
		BITS="\"${CHAR}\""
	fi

	echo "Filling ${PCNTOFSECTOR}% of ${CLIENTDISK} with a stream of ${BITS}...."
	echo "general|erase_diskpercent|${PCNTOFSECTOR}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse

	if [[ $PCNTOFSECTOR == '100' ]]; then
		${SOURCE} | (pv > /dev/${CLIENTDISK})
		return 0
	fi
	
	while [[ $i -le $SECTIONS ]]; do

		echo -e "Writing to section ${i}/${SECTIONS}"
		tput cuu1

		COUNT1=$(shuf -i 1-${COUNT} -n 1)
		SKIP1=$(( $(shuf -i 1-$(( ${SECTIONSIZEMB} / ${DIVPERSEC} )) -n 1) + ${a} / 2 ))
    	${SOURCE} | dd bs=${BS} count=${COUNT1} seek=${SKIP1} of=/dev/${CLIENTDISK} iflag=fullblock status=none 2>/dev/null

		COUNT2=$(shuf -i 1-${COUNT} -n 1)
   		SKIP2=$(( $(shuf -i 1-$(( ${SECTIONSIZEMB} + ${SECTIONSIZEMB} - ${SECTIONSIZEMB} / ${DIVPERSEC} )) -n 1) + ${a} ))
    	${SOURCE} | dd bs=${BS} count=${COUNT2} seek=${SKIP2} of=/dev/${CLIENTDISK} iflag=fullblock status=none 2>/dev/null

		i=$(( ${i} + 1 ))
		a=$(( ${a} + ${SECTIONSIZEMB} ))

	done

	echo ""
	echo "Completely filling the first sector...."
    ${SOURCE} | dd bs=${BS} count=${SECTIONSIZEMB} seek=0 of=/dev/${CLIENTDISK} iflag=fullblock status=none 2>/dev/null
	echo "Completely filling the last sector...."
	${SOURCE} | dd bs=${BS} count=${SECTIONSIZEMB} seek=$(( ${DISKSIZEMB} - ${SECTIONSIZEMB} )) of=/dev/${CLIENTDISK} \
		iflag=fullblock status=none 2>/dev/null
}



function vrfyDisk_Shred {
	
	if [[ -z $SECTIONS ]]; then
		SECTIONS='1000'
	fi

	if [[ -z $PCNTOFSECTOR ]]; then
		PCNTOFSECTOR='100'
	fi

	DIVPERSEC='2'
	BS='1M'
	DISKSIZEMB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 ))
	DISKSIZEGB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 / 1000 ))
	SECTIONSIZEMB=$(( DISKSIZEMB / SECTIONS ))
	COUNT=$(( SECTIONSIZEMB / 100 * PCNTOFSECTOR / 2 ))
	local a='0'
	local i='0'

	if [[ -z $CHAR ]]; then
		CHAR='0'
	fi

	echo "Looking for non-${CHAR}'s on ${CLIENTDISK}...."

	if [[ $PCNTOFSECTOR == '100' ]]; then
		FULLVRFY=$(pv /dev/${CLIENTDISK} | grep -oP -m 1 "[^${CHAR}]" | head -n 1)
		if [[ ${PIPESTATUS[1]} = "1" ]]; then
        	echo "${BOLD}The drive ${CLIENTDISK} is completely and securely wiped.${RESET}"
			PROCFAIL='0'
		else
            PROCFAIL='1'
            echo "${BOLD}${RED}Bad bits found on device${RESET}${BOLD} ${CLIENTDISK}${RESET}${BOLD}.${RESET}"
			echo ""
        	read -p "${BOLD}Press ${BOLD}${GREEN}Enter ${RESET}${BOLD}to continue.${RESET}"
			return 1
		fi
	fi
	
	while [[ $i -le $SECTIONS && $PROCFAIL == '0' ]]; do

		echo "Verifying section ${i}/${SECTIONS}"
		tput cuu1

		COUNT1=$(shuf -i 1-${COUNT} -n 1)
		MATHONE=$(shuf -i 1-$(( SECTIONSIZEMB / DIVPERSEC )) -n 1)
		SKIP1=$(( MATHONE + ${a} / 2 ))
    	if [[ $(dd if=/dev/${CLIENTDISK} bs=${BS} count=${COUNT1} skip=${SKIP1} iflag=fullblock status=none 2>/dev/null \
        	| grep --quiet -oP -m 1 [^${CHAR}]; echo $?) == '0' ]]; then
            	PROCFAIL='1'
            	echo "${BOLD}${RED}Bad bits found on device${RESET}${BOLD} ${CLIENTDISK}${RESET}"
				echo ""
        		read -p "${BOLD}Press ${BOLD}${GREEN}Enter ${RESET}${BOLD}to continue.${RESET}"
				return 1
    	fi

		COUNT2=$(shuf -i 1-${COUNT} -n 1)
		MATHTWO=$(shuf -i 1-$(( SECTIONSIZEMB + SECTIONSIZEMB - SECTIONSIZEMB / DIVPERSEC )) -n 1)
    	SKIP2=$(( MATHTWO + ${a} ))
    	if [[ $(dd if=/dev/${CLIENTDISK} bs=${BS} count=${COUNT2} skip=${SKIP2} iflag=fullblock status=none 2>/dev/null \
        	| grep --quiet -oP -m 1 [^${CHAR}]; echo $?) == '0' ]]; then
            	PROCFAIL='1'
            	echo "${BOLD}${RED}Bad bits found on device${RESET}${BOLD} ${CLIENTDISK}${RESET}"
				echo ""
        		read -p "${BOLD}Press ${BOLD}${GREEN}Enter ${RESET}${BOLD}to continue.${RESET}"
				return 1
    	fi

		i=$(( i + 1 ))
		a=$(( a + SECTIONSIZEMB ))

	done

	echo ""
	echo "Verifing the first sector of the disk...."
	if [[ $(dd if=/dev/${CLIENTDISK} count=${SECTIONSIZEMB} skip=0 iflag=fullblock status=none 2>/dev/null \
        | grep --quiet -oP -m 1 [^${CHAR}]; echo $?) == '0' && $PROCFAIL == '0' ]]; then
            	PROCFAIL='1'
            	echo "${BOLD}${RED}Bad bits found on device${RESET}${BOLD} ${CLIENTDISK}${RESET}"
				echo ""
        		read -p "${BOLD}Press ${BOLD}${GREEN}Enter ${RESET}${BOLD}to continue.${RESSET}"
				return 1
    fi
	echo "Verifing the last sector of the disk...."
    if [[ $(dd if=/dev/${CLIENTDISK} count=${SECTIONSIZEMB} skip=$(( ${DISKSIZEMB} - ${SECTIONSIZEMB} )) \
		iflag=fullblock status=none 2>/dev/null \
        | grep --quiet -oP -m 1 [^${CHAR}]; echo $?) == '0' && $PROCFAIL == '0' ]]; then
            	PROCFAIL='1'
            	echo "${BOLD}${RED}Bad bits found on device${RESET}${BOLD} ${CLIENTDISK}${RESET}"
				echo ""
        		read -p "${BOLD}Press ${BOLD}${GREEN}Enter ${RESET}${BOLD}to continue.${RESSET}"
				return 1
    fi

    echo "${PCNTOFSECTOR}% of ${CLIENTDISK} has been verified."
	if [[ $PROCFAIL == '0' ]]; then
		echo "Test passed successfully!"
		return 0
	else
		echo "Test failed."
		return 1
	fi
}



function secErase_Shred {
	if [[ $CLIENTDISK =~ $SSD_REGEX ]]; then 
		echo "Using Secure Erase on ${CLIENTDISK}. This can take a while, please keep the device powered on...."
		hdparm --user-master u --security-set-pass UHouston /dev/${CLIENTDISK} &>/dev/null
		hdparm --user-master u --security-erase UHouston /dev/${CLIENTDISK} &>/dev/null
	elif [[ $CLIENTDISK =~ $NVME_REGEX ]]; then
		echo "Using Secure Erase on ${CLIENTDISK:0:-2}. This can take a while, please keep the device powered on...."
		nvme format /dev/${CLIENTDISK:0:-2} --ses=1 --namespace-id=1 &>/dev/null
		nvme format /dev/${CLIENTDISK:0:-2} --ses=2 --namespace-id=1 &>/dev/null
	elif [[ $CLIENTDISK =~ $SCSI_REGEX ]]; then
		echo "No compatible SATA or NVME drive is selected. Can't use Secure Erase on ${CLIENTDISK}. Continuing...."
	else
		echo "No compatible SATA or NVME drive is selected. Can't use Secure Erase on ${CLIENTDISK}. Continuing...."
	fi
}



function secUnlock_Shred {
	if [[ $CLIENTDISK =~ $SSD_REGEX ]]; then 
		echo "Unlocking ${CLIENTDISK}, please keep the device powered on...."
		hdparm --user-master u --security-unlock UHouston /dev/${CLIENTDISK} &>/dev/null
		hdparm --user-master u --security-disable UHouston /dev/${CLIENTDISK} &>/dev/null
		echo "${CLIENTDISK} is successfully unlocked."
	elif [[ $CLIENTDISK =~ $NVME_REGEX ]]; then
		echo "NVME drives do not need to be unlocked. Continuing...."
	elif [[ $CLIENTDISK =~ $SCSI_REGEX ]]; then
		echo "No compatible SATA or NVME drive is selected. Can't unlock ${CLIENTDISK}. Continuing...."
	else
		echo "No compatible SATA or NVME drive is selected. Can't unlock ${CLIENTDISK}. Continuing...."
	fi
}



function nistMode_Shred {
	clear
	echo ""
	echo "${BOLD}UIT-TSS-TOOLBOX running in ${BOLD}${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	echo ""

	echo ""
	echo "Step [1/3]:"
	PCNTOFSECTOR='25'
	WMODE='random'
	writeDisk_Shred
	
	echo ""
	echo "Step [2/3]:"
	secErase_Shred
	secUnlock_Shred
	
	echo ""
	echo "Step [3/3]:"
	PCNTOFSECTOR='50'
	CHAR='0'
	vrfyDisk_Shred

	if [[ $PROCFAIL == '1' ]]; then
		echo ""
		echo ""
		echo "Step [1/2]: "
		PCNTOFSECTOR='100'
		WMODE='zero'
		writeDisk_Shred

		echo ""
		echo "Step [2/2]: "
		PCNTOFSECTOR='100'
		CHAR='0'
		vrfyDisk_Shred
	fi
}



function zeroMode_Shred {
	clear
	echo ""
		echo "${BOLD}UIT-TSS-TOOLBOX running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	echo ""

	WMODE='zero'
	CHAR='0'
	if [[ $zeroQuick = "1" ]]; then
		PCNTOFSECTOR='10'
	else
		:
	fi
	echo ""
	echo "Step [1/2]: "
	writeDisk_Shred
	echo ""
	echo "Step [2/2]: "
	vrfyDisk_Shred
}



function dodMode_Shred {
	
	clear
	echo ""
	echo "${BOLD}UIT-TSS-TOOLBOX running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	echo ""

	echo ""
	echo "Step [1/6]: "
	echo ""
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred
	
	echo ""
	echo "Step [2/6]: "
	echo ""
	PCNTOFSECTOR='100'
	CHAR='0'
	vrfyDisk_Shred

	echo ""
	echo "Step [3/6]: "
	echo ""
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred
	
	echo ""
	echo "Step [4/6]: "
	echo ""
	PCNTOFSECTOR='100'
	CHAR='1'
	vrfyDisk_Shred

	echo ""
	echo "Step [5/6]: "
	echo ""
	WMODE='randBit_Shred'
	PCNTOFSECTOR='100'
	writeDisk_Shred
	
	echo ""
	echo "Step [6/6]: "
	echo ""
	PCNTOFSECTOR='100'
	CHAR=${RANDBIT}
	vrfyDisk_Shred
}



function rcmpMode_Shred {

	clear
	echo ""
	echo "${BOLD}UIT-TSS-TOOLBOX running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	echo ""

	echo ""
	echo "Step [1/8]: "
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	echo ""
	echo "Step [2/8]: "
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred

	echo ""
	echo "Step [3/8]: "
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred
	
	echo ""
	echo "Step [4/8]: "
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred

	echo ""
	echo "Step [5/8]: "
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	echo ""
	echo "Step [6/8]: "
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred

	echo ""
	echo "Step [7/8]: "
	echo ""
	WMODE='randBit_Shred'
	PCNTOFSECTOR='100'
	writeDisk_Shred
	
	echo ""
	echo "Step [8/8]: "
	echo ""
	PCNTOFSECTOR='100'
	CHAR="${RANDBIT}"
	vrfyDisk_Shred

}



function schneierMode_Shred {

	clear
	echo ""
	echo "${BOLD}UIT-TSS-TOOLBOX running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	echo ""

	echo ""
	echo "Step [1/7]: "
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred

	echo ""
	echo "Step [2/7]: "
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	echo ""
	echo "Step [3/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	echo ""
	echo "Step [4/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	echo ""
	echo "Step [5/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	echo ""
	echo "Step [6/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	echo ""
	echo "Step [7/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

}



function gutmann {
	COUNT='0'
	GUTMANNARRAY=(01010101 10101010 10010010 01001001 00100100 00000000 00010001 00100010)
	GUTMANNARRAY+=(00110011 01000100 01010101 01100110 01110111 10001000 10011001 10101010)
	GUTMANNARRAY+=(10111011 11001100 11011101 11101110 11111111 10010010 01001001 00100100)
	GUTMANNARRAY+=(01101101 10110110 11011011)

	clear
	echo ""
	echo "${BOLD}UIT-TSS-TOOLBOX running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	echo ""

	
	while [[ $COUNT -le 35 ]]; do 

		if [[ $COUNT -le 4 ]]; then
			echo ""
			echo "[${COUNT}/35] Writing \"${RANDOMPATTERN}\" to ${CLIENTDISK}"
			WMODE='randPattern_Shred'
			PCNTOFSECTOR='100'
			writeDisk_Shred
		fi

		if [[ $COUNT -le 31 && $COUNT -gt 4 ]]; then
			WMODE='char'
			PCNTOFSECTOR='100'
			for i in ${GUTMANNARRAY[@]}; do
				RANDNUM=$(shuf -i 1-26 -n 1)
				CHAR=${GUTMANARRAY[$RANDNUM]}
			done
			echo "[${COUNT}/35] Writing pattern ${CHAR} to ${CLIENTDISK}"
			writeDisk_Shred
		fi

		if [[ $COUNT -gt 31 ]]; then
			echo ""
			echo "[${COUNT}/35] Writing \"${RANDOMPATTERN}\" to ${CLIENTDISK}"
			WMODE='randPattern_Shred'
			PCNTOFSECTOR='100'
			writeDisk_Shred
		fi

	done

	echo ""
	echo ""
	echo "The drive ${CLIENTDISK} is erased using Gutmann's method."
}



function verifyMode_Shred {
	clear
	echo ""
	echo "${BOLD}UIT-TSS-TOOLBOX running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	echo ""
	
	echo ""
	echo "Select the desired level of verification."
	echo ""

	echo ""
	echo "${BOLD}${GREEN}[1]${RESET} ${BOLD}Full verification (Default)${RESET}
	-Longest, verifies every bit on the disk"

	echo ""
	echo "${BOLD}${GREEN}[2]${RESET} ${BOLD}Moderate verification${RESET}
	-10000 divisions, 75% verified"

	echo ""
	echo "${BOLD}${GREEN}[3]${RESET} ${BOLD}Medium verification${RESET}
	-5000 divisions, 50% verified"

	echo ""
	echo "${BOLD}${GREEN}[4]${RESET} ${BOLD}Fast verification${RESET}
	-2500 divisions, 25% verified"

	echo ""
	echo "${BOLD}${GREEN}[5]${RESET} ${BOLD}Very fast verification${RESET}
	-1000 divisions, 10% verified"

	echo ""
	read -n 1 -p "${BOLD}Please select [1-5]:${RESET} " VRFYSELECT
	echo ""

	case $VRFYSELECT in
	1)
	VRFYMODE='full'
	;;
	2)
	VRFYMODE='moderate'
	;;
	3)
	VRFYMODE='medium'
	;;
	4)
	VRFYMODE='fast'
	;;
	5)
	VRFYMODE='vfast'
	;;
	*)
	echo ""
	echo ""
	echo "Incorrect input selected, please try again"
	sleep 1
	verifyMode_Shred
	;;
	esac

	echo ""
	echo "Mode is ${VRFYMODE}"
	echo ""
	read -p "Which character/pattern would you like to verify?: " CHAR
	echo ""

	if [[ $VRFYMODE == 'full' ]]; then
		PCNTOFSECTOR='100'
		CHAR=${CHAR}
		vrfyDisk_Shred
	fi

	if [[ $VRFYMODE == 'moderate' ]]; then
		SECTIONS='10000'
		PCNTOFSECTOR='75'
		CHAR=${CHAR}
		vrfyDisk_Shred
	fi

	if [[ $VRFYMODE == 'medium' ]]; then
		SECTIONS='5000'
		PCNTOFSECTOR='50'
		CHAR=${CHAR}
		vrfyDisk_Shred
	fi

	if [[ $VRFYMODE == 'fast' ]]; then
		SECTIONS='2500'
		PCNTOFSECTOR='25'
		CHAR=${CHAR}
		vrfyDisk_Shred
	fi

	if [[ $VRFYMODE == 'vfast' ]]; then
		PCNTOFSECTOR='10'
		CHAR=${CHAR}
		vrfyDisk_Shred
	fi
}



function unlockMode_Shred {
	clear
	echo ""
	echo "${BOLD}UIT-TSS-TOOLBOX running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	echo ""
	
	secUnlock_Shred
}



function clientselect_Clone {
	footer
	echo "${BOLD}Please select a ${BOLD}${BLUE}clone mode${RESET}${BOLD}: "
	echo "   ${BOLD}${GREEN}[1]${RESET} ${BOLD}Restore${RESET} ${DIM}(server -> client)${RESET}"
	echo "   ${BOLD}${GREEN}[2]${RESET} ${BOLD}Save${RESET} ${DIM}(client -> server)${RESET}"
	read -n1 -p "${BOLD}Enter [1-2]:${RESET} " cloneMode
	echo ""
	echo ""
	case $cloneMode in
		1)
			cloneMode="restoredisk"
		;;
		2)
			cloneMode="savedisk"
		;;
		*)
			echo "${BOLD}${RED}Error - Invalid input${RESET}"
		;;
	esac

	footer
	echo "${BOLD}Select which ${BOLD}${BLUE}image${RESET} you are cloning:${RESET} "
	echo "   ${BOLD}${GREEN}[1]${RESET} ${BOLD}Tech Commons HP laptops${RESET}"
	echo "   ${BOLD}${GREEN}[2]${RESET} ${BOLD}Tech Commons Dell laptops${RESET}"
	echo "   ${BOLD}${GREEN}[3]${RESET} ${BOLD}Tech Commons Dell desktops${RESET}"
	echo "   ${BOLD}${GREEN}[4]${RESET} ${BOLD}SHRL Dell desktops${RESET}"
	echo "   ${BOLD}${GREEN}[5]${RESET} ${BOLD}Ubuntu Desktop${RESET}"
	read -n1 -p "${BOLD}Enter [1-5]:${RESET} " CLIENTTYPE
	echo ""
	case $CLIENTTYPE in
	1)
	cloneImgName='TechCommons-HP-Laptops'
	echo "general|clone_image|${cloneImgName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	;;
	2)
	cloneImgName='TechCommons-Dell-Laptops'
	echo "general|clone_image|${cloneImgName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	;;
	3)
	cloneImgName='TechCommons-Dell-Desktops'
	echo "general|clone_image|${cloneImgName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	;;
	4)
	cloneImgName='SHRL-Dell-Desktops'
	echo "general|clone_image|${cloneImgName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	;;
	5)
	cloneImgName='Ubuntu-Desktop'
	echo "general|clone_image|${cloneImgName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	;;
	*)
	clientselect_Clone
	;;
	esac
}



function execute_Clone {
	SECONDS=0
	start_time=$SECONDS
	sambaUser="cameron"
	sambaPassword='UHouston!'
	sambaServer="10.0.0.1"
	sambaDNS="mickey.uit"
	echo "general|clone_sambauser|${sambaUser}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	echo "general|clone_server|${sambaDNS}/${sambaServer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	umount /home/partimag &>/dev/null
	mkdir -p /home/partimag
	modprobe fuse
	#sshfs -o allow_other,default_permissions ${sambaUser}@${sambaServer}:/home/${sambaPath} /home/partimag
	mount -t nfs ${sambaServer}:/home/${sambaPath} /home/partimag
	if [[ $cloneMode == "restoredisk" ]]; then
		tput reset
		info
		sleep 1
		/usr/sbin/ocs-sr --language en_US.UTF-8 --postaction command --user-mode beginner \
			-k1 --skip-check-restorable-r ${cloneMode} ${cloneImgName} ${CLIENTDISK}
	fi
	if [[ $cloneMode == "savedisk" ]]; then
		tput reset
		info
		sleep 1
		/usr/sbin/ocs-sr --language en_US.UTF-8 --postaction command --user-mode beginner \
			--skip-enc-ocs-img --skip-fsck-src-part --use-partclone -z8 ${cloneMode} ${cloneImgName} ${CLIENTDISK}
	fi
	cloneElapsed=$(( SECONDS - start_time))
	echo "general|clone_time|${cloneElapsed}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	return
}



function execute_Shred {
	if [[ $APPSELECT == "EC" || $APPSELECT == "E" ]]; then
		SECONDS=0
		start_time=$SECONDS
		if [[ $shredMode == 'nist' ]]; then
			nistMode_Shred
		fi

		if [[ $shredMode == 'zero' ]]; then
			zeroMode_Shred
		fi

		if [[ $shredMode == 'dod' ]]; then
			dodMode_Shred
		fi

		if [[ $shredMode == 'rcmp' ]]; then
			rcmpMode_Shred
		fi
	
		if [[ $shredMode == 'gutmann' ]]; then
			gutmann
		fi
	
		if [[ $shredMode == 'schneier' ]]; then
			schneierMode_Shred
		fi
	
		if [[ $shredMode == 'verify' ]]; then
			verifyMode_Shred
		fi

		if [[ $shredMode == 'unlock' ]]; then
			unlockMode_Shred
		fi
		shredElapsed=$(( SECONDS - start_time ))
		echo "general|erase_time|${shredElapsed}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	fi
	return
}



function execute {

	if [[ $cloneMode == "savedisk" && ($APPSELECT == "E" || $APPSELECT == "EC") ]]; then
		echo "${RED}Cannot erase device and save its image.${RESET}"
		read -p "${BOLD}Please press ${BOLD}${GREEN}enter${RESET} to restart UIT-TSS-TOOLBOX${RESET}."
		exit 1
	fi

	if [[ $APPSELECT == "EC" ]]; then
		if [[ -z $cloneMode ]]; then
			clientselect_Clone
		fi
		basicEraseMode_Shred
		execute_Shred
		execute_Clone
	elif [[ $APPSELECT == "E" ]]; then
		if [[ -z $shredMode ]]; then
			advEraseMode_Shred
		else
			basicEraseMode_Shred
		fi
		execute_Shred
	elif [[ $APPSELECT == "C" ]]; then
		if [[ -z $cloneMode ]]; then
			clientselect_Clone
		fi
		execute_Clone
	else
		echo "${BOLD}${RED}Error - Invalid application selected.${RESET}"
		sleep 0.5
		exit
	fi

}


function totaltime {
	totalElapsed=$(echo $(( (shredElapsed + cloneElapsed) / 60 )))
	echo "general|all_time|${totalElapsed}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
}


function location {
	RED=$(tput setaf 1)
	GREEN=$(tput setaf 2)
	BLUE=$(tput setaf 4)
	BOLD=$(tput bold)
	DIM=$(tput dim)
	RESET=$(tput sgr0)

	echo ""
	sql=$(mysql --user="laptops" --password="UHouston!" --database="laptopDB" --host="10.0.0.1" -s -N \
		--execute="SELECT chassis_serial FROM locations WHERE tagnumber = '${tagNum}' ORDER BY time DESC LIMIT 1;" 2>/dev/null)
	echo "The last reported serial number for ${tagNum} was: ${BOLD}${sql}${RESET}"
	if [[ $sql == "NULL" ]]; then
		read -p "Please enter the ${BOLD}${GREEN}serial number${RESET}: " serial
	else
		serial="${sql}"
	fi
	sql=$(mysql --user="laptops" --password="UHouston!" --database="laptopDB" --host="10.0.0.1" -s -N \
		--execute="SELECT location FROM locations WHERE tagnumber = '${tagNum}' ORDER BY time DESC LIMIT 1;" 2>/dev/null)
	echo "The last reported location for ${tagNum} was: ${BOLD}${sql}${RESET}"
	read -p "Please enter the ${BOLD}${GREEN}location${RESET}: " location
	read -n 1 -p "Please enter the ${BOLD}${GREEN}status${RESET} ${BOLD}${GREEN}[1] ${RESET}${BOLD}Functioning ${BOLD}${GREEN}[2] ${RESET}${BOLD}Broken${RESET}: " status

	if [[ $status == "1" ]]; then
		status="functioning"
		problem=""
	elif [[ $status == "2" ]]; then
		echo ""
		sql=$(mysql --user="laptops" --password="UHouston!" --database="laptopDB" --host="10.0.0.1" -s -N \
			--execute="SELECT problem FROM locations WHERE tagnumber = '${tagNum}' ORDER BY time DESC LIMIT 1;" 2>/dev/null)
		echo "The last reported issue for ${tagNum} was: ${BOLD}${sql}${RESET}"
		status="broken"
		read -p "Please enter the ${BOLD}${GREEN}problem${GREEN}${RESET}: " problem
	else
		status=""
		problem=""
	fi

	echo "location|custom|${tagNum}|${serial}|${location}|${status}|${problem}" | /var/lib/UIT-TSS-TOOLBOX/parse
}


function terminate {
	tput reset
	totaltime
	sleep 1
	echo "location|end|${tagNum}|${tOneSerialNumber}" | /var/lib/UIT-TSS-TOOLBOX/parse
	/usr/bin/play /root/oven.mp3 &> /dev/null
	echo "${BOLD}Process has finished!${RESET}"
	echo ""
	imgupdate=$(mysql --user="laptops" --password="UHouston!" --database="laptopDB" --host="10.0.0.1" -s -N \
	--execute="SELECT last_image_update FROM serverstats WHERE date = '${DATE}';")

	location

	cloneNumToday=$(mysql --user="laptops" --password="UHouston!" --database="laptopDB" --host="10.0.0.1" -s -N \
	--execute="SELECT COUNT(tagnumber) FROM jobstats WHERE clone_completed = 'Yes' AND date = '${DATE}';" 2>/dev/null)

	eraseNumToday=$(mysql --user="laptops" --password="UHouston!" --database="laptopDB" --host="10.0.0.1" -s -N \
	--execute="SELECT COUNT(tagnumber) FROM jobstats WHERE erase_completed = 'Yes' AND date = '${DATE}';" 2>/dev/null)

	clientCloneTotal=$(mysql --user="laptops" --password="UHouston!" --database="laptopDB" --host="10.0.0.1" -s -N \
	--execute="SELECT COUNT(tagnumber) FROM jobstats WHERE clone_completed = 'Yes' AND tagnumber = '${tagNum}';" 2>/dev/null)

	jobsToday=$(( cloneNumToday + eraseNumToday ))

	echo ""
	if [[ $cloneMode == "restoredisk" && ($APPSELECT == "C" || $APPSELECT == "EC") ]]; then
		echo "general|clone_imageupdate|${imgupdate}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse

		if [[ $cloneMode == "restoredisk" && $APPSELECT == "EC" ]]; then
			terminateAction="Erased and cloned"
		fi

		if [[ $cloneMode == "restoredisk" && $APPSELECT == "C" ]]; then
			terminateAction="Cloned"
		fi

		terminateMessage=$(echo "Tag#: ${tagNum}"
		echo "MAC: ${etherAddr}"
		echo "Action: ${terminateAction}"
		echo "Total time taken: ${totalElapsed} minutes"
		echo "Server: \"${sambaDNS}\""
		echo "Image: \"${cloneImgName}\""
		echo "Total jobs today: ${jobsToday}"
		)

		echo "general|clone_completed|Yes|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse

		if [[ $APPSELECT == "EC" ]]; then
			echo "general|erase_completed|Yes|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		fi
	fi
	
	if [[ $cloneMode == "savedisk" && $APPSELECT == "C" ]]; then
		imgupdate=$(date --iso)

		terminateMessage=$(echo "Tag#: ${tagNum}"
		echo "MAC: ${etherAddr}"
		echo "Action: ${terminateAction}"
		echo "Total time taken: ${totalElapsed} minutes"
		echo "Server: \"${sambaDNS}\""
		echo "Image: \"${cloneImgName}\""
		echo "Total jobs today: ${jobsToday}"
		)

		echo "general|clone_completed|Yes|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		echo "general|clone_master|Yes|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	fi

	if [[ $APPSELECT == "E" ]]; then
		terminateAction="erased"

		terminateMessage=$(echo "Tag#: ${tagNum}"
		echo "MAC: ${etherAddr}"
		echo "Action: ${terminateAction}"
		echo "Total time taken: ${totalElapsed} minutes"
		echo "Total jobs today: ${jobsToday}"
		)

		echo "general|erase_completed|Yes|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
	fi

	echo "${terminateMessage}"
	echo "update|${tagNum}" | /var/lib/UIT-TSS-TOOLBOX/parse
	echo ""
	echo ""
	read -p "${BOLD}Process has finished. Press ${GREEN}Enter${RESET}${BOLD} to shutdown...${RESET} "
	poweroff
}



function main {
	tput reset
	enterTag
	tput reset
	hardwareData
	intro
	if [[ $mainMenuOpt == "1" ]]; then
		APPSELECT="EC"
		ACTION="erase and clone"
			echo "general|action|${ACTION}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		CLIENTDISK='nvme0n1'
			echo "general|disk|${CLIENTDISK}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		cloneMode="restoredisk"
			echo "general|clone_mode|${cloneMode}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		cloneImgName="TechCommons-HP-Laptops"
			echo "general|clone_image|${cloneImgName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		shredMode="autodetect"
		RMODE="autodetect"
			echo "general|erase_mode|${RMODE}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		sambaUser="cameron"
		sambaPassword="UHouston!"
		sambaServer="10.0.0.1"
		sambaDNS="mickey.uit"
			echo "general|clone_sambauser|${sambaUser}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
			echo "general|clone_server|${sambaDNS}/${sambaServer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		powerWarning
		execute
	elif [[ $mainMenuOpt == "2" ]]; then
		APPSELECT="EC"
		ACTION="erase and clone"
			echo "general|action|${ACTION}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		CLIENTDISK='nvme0n1'
			echo "general|disk|${CLIENTDISK}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		cloneMode="restoredisk"
			echo "general|clone_mode|${cloneMode}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		cloneImgName="TechCommons-Dell-Laptops"
			echo "general|clone_image|${cloneImgName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		shredMode="autodetect"
		RMODE="autodetect"
			echo "general|erase_mode|${RMODE}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		sambaUser="cameron"
		sambaPassword="UHouston!"
		sambaServer="10.0.0.1"
		sambaDNS="mickey.uit"
			echo "general|clone_sambauser|${sambaUser}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
			echo "general|clone_server|${sambaDNS}/${sambaServer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		powerWarning
		execute
	elif [[ $mainMenuOpt == "3" ]]; then
		APPSELECT="EC"
		ACTION="erase and clone"
			echo "general|action|${ACTION}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		CLIENTDISK='sda'
			echo "general|disk|${CLIENTDISK}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		cloneMode="restoredisk"
			echo "general|clone_mode|${cloneMode}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		cloneImgName="TechCommons-Dell-Laptops"
			echo "general|clone_image|${cloneImgName}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		shredMode="autodetect"
		RMODE="autodetect"
			echo "general|erase_mode|${RMODE}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		sambaUser="cameron"
		sambaPassword="UHouston!"
		sambaServer="10.0.0.1"
		sambaDNS="mickey.uit"
			echo "general|clone_sambauser|${sambaUser}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
			echo "general|clone_server|${sambaDNS}/${sambaServer}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		powerWarning
		execute
	elif [[ $mainMenuOpt == "4" ]]; then
		APPSELECT="E"
		ACTION="erase"
			echo "general|action|${ACTION}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		CLIENTDISK='nvme0n1'
			echo "general|disk|${CLIENTDISK}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		shredMode="autodetect"
		RMODE="autodetect"
			echo "general|erase_mode|${RMODE}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		powerWarning
		execute
	elif [[ $mainMenuOpt == "5" ]]; then
		APPSELECT="E"
		ACTION="erase"
			echo "general|action|${ACTION}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		CLIENTDISK='sda'
			echo "general|disk|${CLIENTDISK}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		shredMode="autodetect"
		RMODE="autodetect"
			echo "general|erase_mode|${RMODE}|${UUID}" | /var/lib/UIT-TSS-TOOLBOX/parse
		powerWarning
		execute
	elif [[ $mainMenuOpt == "9" ]]; then
		appSelect
		diskSelect
		execute
	elif [[ $mainMenuOpt == "0" ]]; then
		:
	else
		exit 1
	fi
	terminate
}

main
