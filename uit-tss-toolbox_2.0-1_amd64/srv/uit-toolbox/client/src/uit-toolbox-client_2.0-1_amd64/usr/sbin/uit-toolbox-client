#!/bin/bash
SSD_REGEX='sd.*'
NVME_REGEX='nvme.*'
SCSI_REGEX='hd.*'
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
BLUE=$(tput setaf 4)
BOLD=$(tput bold)
DIM=$(tput dim)
RESET=$(tput sgr0)
cloneElapsed="0"
shredElapsed="0"

for i in $(ps | grep 'uit-cpu' | awk '{ print $1 }'); do kill "${i}" 2>/dev/null; done
for i in $(ps | grep 'uit-network' | awk '{ print $1 }'); do kill "${i}" 2>/dev/null; done
for i in $(ps | grep 'uit-sql' | awk '{ print $1 }'); do kill "${i}" 2>/dev/null; done

printf '%s' '0' > /root/uptime
printf '%s' '0' > /tmp/cpu-usage.txt
printf '%s' '0' > /tmp/network-usage.txt

umount /home/partimag 2>/dev/null

printf '\n'
printf '%s\n' "${BOLD}Changing font...${RESET}"
setupcon
DefaultFontLines=$(tput lines)
/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus32x16.psf.gz &>/dev/null
XLFontLines=$(tput lines)
/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus28x14.psf.gz &>/dev/null
LFontLines=$(tput lines)
/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus24x12.psf.gz &>/dev/null
MFontLines=$(tput lines)
/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus22x11.psf.gz &>/dev/null
SFontLines=$(tput lines)
/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus20x10.psf.gz &>/dev/null
XSFontLines=$(tput lines)
/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus18x10.psf.gz &>/dev/null
XXSFontLines=$(tput lines)

unset fontArr
declare -A fontArr
fontArr["XL"]=$XLFontLines
fontArr["L"]=$LFontLines
fontArr["M"]=$MFontLines
fontArr["S"]=$SFontLines
fontArr["XS"]=$XSFontLines
fontArr["XXS"]=$XXSFontLines

targetRows=33
minDifference=$(( targetRows - DefaultFontLines ))
if [[ $minDifference -lt 0 ]]; then minDifference=$(( -1 * minDifference )); fi
for key in ${!fontArr[@]}; do
	value=${fontArr[${key}]}
	difference=$(( targetRows - value ))
	if [[ difference -lt 0 ]]; then
		difference=$(( -1 * difference ))
	fi

	if [[ $difference -lt $minDifference ]]; then
		minDifference=$difference
		fontValue=$key
	fi
done

if [[ $fontValue == "XL" ]]; then
	/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus32x16.psf.gz &>/dev/null
elif [[ $fontValue == "L" ]]; then
	/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus28x14.psf.gz &>/dev/null
elif [[ $fontValue == "M" ]]; then
	/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus24x12.psf.gz &>/dev/null
elif [[ $fontValue == "S" ]]; then
	/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus22x11.psf.gz &>/dev/null
elif [[ $fontValue == "XS" ]]; then
	/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus20x10.psf.gz &>/dev/null
elif [[ $fontValue == "XXS" ]]; then
	/usr/bin/setfont /usr/share/consolefonts/Uni3-Terminus18x10.psf.gz &>/dev/null
fi

printf '%s\n' "${GREEN}Done.${RESET}"

printf '\n'
printf '%s\n' "${BOLD}Changing brightness...${RESET}"
maxBrightness=$(cat /sys/class/backlight/*/max_brightness)
printf '%s' "${maxBrightness}" > /sys/class/backlight/*/brightness 2>/dev/null
printf '%s\n' "${GREEN}Done.${RESET}"

printf '\n'
printf '%s\n' "${BOLD}Configuring networking....${RESET}"
for i in $(ip addr | awk '/state UP/ {print $2}' | sed 's/://g'); do
  	ip addr flush dev ${iface}
  	dhclient -r ${iface}
  	dhclient -4 ${iface}
 done &>/dev/null
 printf '%s\n' "${GREEN}Done.${RESET}"

printf '\n'
printf '%s\n' "${BOLD}Syncing time...${RESET}"
printf '%s\n' "[Time]
NTP=10.0.0.1" > /etc/systemd/timesyncd.conf

systemctl daemon-reload &>/dev/null
/usr/bin/timedatectl set-timezone 'America/Chicago'
/usr/bin/timedatectl set-ntp true
/usr/bin/timedatectl set-local-rtc false

/usr/bin/chronyc add server 10.0.0.1 iburst
/usr/bin/chronyc makestep

while [[ $(printf '%s' "SELECT TO_CHAR(NOW(), 'YYYY-MM-DD HH24:MI:ss') AS result" | /opt/uit-toolbox/select) != $(date '+%Y-%m-%d %H:%M:%S') ]]; do
	sleep 0.01
done
printf '%s\n' "${GREEN}Done.${RESET}"

printf '\n'
printf '%s\n' "${BOLD}Running disk checks....${RESET}"
if [[ -f /root/smartctl-data ]]; then
	rm /root/smartctl-data
fi
for i in $(lsblk -o NAME --nodeps --noheadings --exclude 1,2,7,11); do
	if [[ $(cat /sys/block/${i}/removable) == 0 ]]; then
		smartctl -t short -a /dev/${i} > /root/smartctl-data
	fi
done
printf '%s\n' "${GREEN}Done.${RESET}"


printf '\n'
printf '%s\n' "${BOLD}Configuring audio...${RESET}"
/usr/bin/amixer sset Master 100% &>/dev/null
/usr/bin/amixer set Master unmute &>/dev/null
/usr/bin/amixer sset Speakers 100% &>/dev/null
/usr/sbin/amixer set Speakers unmute &>/dev/null
printf '%s\n' "${GREEN}Done.${RESET}"


systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target


etherAddr=$(for i in $(ip addr | awk '/state UP/ {print $2}' | sed 's/://g'); do cat /sys/class/net/${i}/address; done)
wifiMac=$(cat /sys/class/ieee80211/phy*/macaddress 2>/dev/null)
systemSerial=$(dmidecode --string system-serial-number)
ipAddr=$(ip addr | grep -C 2 'state UP' | grep 'inet' | grep -oP '10.0.0.[0-9]{1,3}/16' | sed 's/\/16//g')


function remote {
	job_queued=$(printf '%s' "SELECT job_queued AS result FROM remote WHERE tagnumber = '${tagNum}'" | /opt/uit-toolbox/select)
	job_queued_override=$(printf '%s' "SELECT job_queued AS result FROM remote WHERE job_queued IN ('hpEraseAndClone', 'hpCloneOnly', 'generic-erase+clone', 'generic-clone') AND tagnumber = '${tagNum}'" | /opt/uit-toolbox/select)
	job_queued_formatted=$(printf '%s' "SELECT (CASE WHEN job_queued = 'data collection' THEN 'data collection' WHEN job_queued = 'update' THEN 'update' WHEN job_queued = 'findmy' THEN 'playing a sound' WHEN (job_queued = 'hpEraseAndClone' OR job_queued = 'generic-erase+clone') THEN 'disk erase & clone' WHEN (job_queued = 'hpCloneOnly' OR job_queued = 'generic-clone') THEN 'disk clone' WHEN job_queued = 'nvmeErase' THEN 'disk erase' WHEN job_queued = 'nvmeVerify' THEN 'disk verify' WHEN job_queued = 'shutdown' THEN 'shutdown' WHEN job_queued = 'clean-shutdown' THEN 'shutdown' ELSE job_queued END) AS result FROM remote WHERE tagnumber = '${tagNum}'" | /opt/uit-toolbox/select) 
	job_queued_position=$(printf '%s' "SELECT * FROM (SELECT tagnumber, ROW_NUMBER() OVER (ORDER BY tagnumber) AS result FROM (SELECT tagnumber FROM remote WHERE (job_active = FALSE OR job_active IS NULL) AND job_queued IS NOT NULL AND job_queued IN ('hpEraseAndClone', 'hpCloneOnly', 'generic-erase+clone', 'generic-clone') ORDER BY tagnumber ASC)) s1 WHERE s1.tagnumber = '${tagNum}'" | /opt/uit-toolbox/select)
	job_active=$(printf '%s' "SELECT job_active AS result FROM remote WHERE tagnumber = '${tagNum}'" | /opt/uit-toolbox/select)
	job_available=$(printf '%s' "SELECT COUNT(tagnumber) AS result FROM remote WHERE job_queued IN ('hpEraseAndClone', 'hpCloneOnly', 'generic-erase+clone', 'generic-clone') AND job_active = TRUE" | /opt/uit-toolbox/select)
}


DATE=$(date --iso)
linuxPath="images"

tput reset

function diskData {
		###Disk Data
	for i in $(lsblk -o NAME --nodeps --noheadings --exclude 1,2,7,11); do
		if [[ $(cat /sys/block/${i}/removable) == 0 ]]; then
			DISK="$i"
			if [[ -f /root/smartctl-data ]]; then
				rm /root/smartctl-data
			fi
			smartctl -t short -a /dev/${i} > /root/smartctl-data
			printf '%s' "general|disk|${DISK}|${UUID}" | /opt/uit-toolbox/parse
		fi


		if [[ $DISK =~ $NVME_REGEX ]]; then
		diskModel=$(cat /root/smartctl-data | grep '^Model Number: ' | sed 's/Model Number: *//g')
			printf '%s' "general|disk_model|${diskModel}|${UUID}" | /opt/uit-toolbox/parse
		diskSerial=$(cat /root/smartctl-data | grep '^Serial Number: ' | sed 's/Serial Number: *//g')
			printf '%s' "general|disk_serial|${diskSerial}|${UUID}" | /opt/uit-toolbox/parse
		diskFirmware=$(cat /root/smartctl-data | grep '^Firmware Version: ' | sed 's/Firmware Version: *//g')
			printf '%s' "general|disk_firmware|${diskFirmware}|${UUID}" | /opt/uit-toolbox/parse
		diskTemp=$(cat /root/smartctl-data | grep '^Temperature: ' | sed 's/[^0-9]//g')
			printf '%s' "general|disk_temp|${diskTemp}|${UUID}" | /opt/uit-toolbox/parse
		diskSize=$(( $(cat /root/smartctl-data | grep 'Size/Capacity' | sed 's/,//g' | awk '{print $4}') / 1000000000 ))
			printf '%s' "general|disk_size|${diskSize}|${UUID}" | /opt/uit-toolbox/parse
		diskReadsLBA=$(cat /root/smartctl-data | grep '^Data Units Read: ' | sed 's/,//g' | awk '{print $4}')
			printf '%s' "general|disk_reads|${diskReadsLBA}|${UUID}|nvme" | /opt/uit-toolbox/parse
		diskWritesLBA=$(cat /root/smartctl-data | grep '^Data Units Written: ' | sed 's/,//g' | awk '{print $4}')
			printf '%s' "general|disk_writes|${diskWritesLBA}|${UUID}|nvme" | /opt/uit-toolbox/parse
		diskPowerOnHours=$(cat /root/smartctl-data | grep '^Power On Hours: ' | awk '{print $4}' | sed 's/,//g')
			printf '%s' "general|disk_power_on_hours|${diskPowerOnHours}|${UUID}" | /opt/uit-toolbox/parse
		diskPowerCycles=$(cat /root/smartctl-data | grep '^Power Cycles: ' | awk '{print $3}' | sed 's/,//g')
			printf '%s' "general|disk_power_cycles|${diskPowerCycles}|${UUID}" | /opt/uit-toolbox/parse
		diskType=nvme
			printf '%s' "general|disk_type|${diskType}|${UUID}" | /opt/uit-toolbox/parse
		# Disk errors
		diskGenericErr=$(cat /root/smartctl-data | grep 'Error Information Log Entries:' | awk '{print $5}' | sed 's/,//g')
		diskDataErr=$(cat /root/smartctl-data | grep 'Media and Data Integrity Errors:' | awk '{print $6}' | sed 's/,//g')

		diskErrors=$(( diskGenericErr + diskDataErr ))
			printf '%s' "general|disk_errors|${diskErrors}|${UUID}" | /opt/uit-toolbox/parse
		fi

		if [[ $DISK =~ $SSD_REGEX ]]; then
		diskModel=$(cat /root/smartctl-data | grep '^Device Model: ' | sed 's/Device Model: *//g')
			printf '%s' "general|disk_model|${diskModel}|${UUID}" | /opt/uit-toolbox/parse
		diskSerial=$(cat /root/smartctl-data | grep '^Serial Number: ' | sed 's/Serial Number: *//g')
			printf '%s' "general|disk_serial|${diskSerial}|${UUID}" | /opt/uit-toolbox/parse
		diskFirmware=$(cat /root/smartctl-data | grep '^Firmware Version: ' | sed 's/Firmware Version: *//g')
			printf '%s' "general|disk_firmware|${diskFirmware}|${UUID}" | /opt/uit-toolbox/parse
		diskTemp=$(cat /root/smartctl-data | grep '194 Temperature_Celsius' | awk '{print $10}')
			printf '%s' "general|disk_temp|${diskTemp}|${UUID}" | /opt/uit-toolbox/parse
		diskSize=$(( $(cat /root/smartctl-data | grep '^User Capacity' | sed 's/,//g' | awk '{print $3}') / 1000000000 ))
			printf '%s' "general|disk_size|${diskSize}|${UUID}" | /opt/uit-toolbox/parse

		# Disk reads
		diskReadsGiB=$(cat /root/smartctl-data | grep '242 Total_Reads_GiB' | awk '{print $10}')
		if [[ -n $diskReadsGiB ]]; then
			printf '%s' "general|disk_reads|${diskReadsGiB}|${UUID}|sata|gib" | /opt/uit-toolbox/parse
		fi

		diskReadsLBA=$(cat /root/smartctl-data | grep '242 Total_LBAs_Read' | awk '{print $10}')
		if [[ -n $diskReadsLBA ]]; then
			printf '%s' "general|disk_reads|${diskReadsLBA}|${UUID}|sata" | /opt/uit-toolbox/parse
		fi

		# Disk writes
		diskWritesGiB=$(cat /root/smartctl-data | grep '241 Total_Writes_GiB' | awk '{print $10}')
		if [[ -n $diskWritesGiB ]]; then
			printf '%s' "general|disk_writes|${diskWritesGiB}|${UUID}|sata|gib" | /opt/uit-toolbox/parse
		fi
		
		diskWritesLBA=$(cat /root/smartctl-data | grep '241 Total_LBAs_Written' | awk '{print $10}')
		if [[ -n $diskWritesLBA ]]; then
			printf '%s' "general|disk_writes|${diskWritesLBA}|${UUID}|sata" | /opt/uit-toolbox/parse
		fi

		diskType=$(lsblk --nodeps --output NAME,ROTA | grep -i "${DISK}"  | awk '{ print $2 }' | tail -n 1)
			printf '%s' "general|disk_type|${diskType}|${UUID}" | /opt/uit-toolbox/parse
			if [[ $diskType == "1" ]]; then
				diskType="hdd"
				else
				diskType="ssd"
			fi
		diskPowerOnHours=$(cat /root/smartctl-data | grep '9 Power_On_Hours' | awk '{print $10}')
			printf '%s' "general|disk_power_on_hours|${diskPowerOnHours}|${UUID}" | /opt/uit-toolbox/parse

		diskPowerCycles=$(cat /root/smartctl-data | grep '12 Power_Cycle_Count' | awk '{print $10}' | sed 's/,//g')
			printf '%s' "general|disk_power_cycles|${diskPowerCycles}|${UUID}" | /opt/uit-toolbox/parse

		# Disk errors
		diskErrors=$(cat /root/smartctl-data | grep 'ATA Error Count:' | awk '{print $4}' | sed 's/,//g')
			printf '%s' "general|disk_errors|${diskErrors}|${UUID}" | /opt/uit-toolbox/parse
		fi
	done
}


function systemData {
	# WiFi MAC Address
	wifiMac=$(cat /sys/class/ieee80211/phy*/macaddress 2>/dev/null)
	printf '%s' "system_data|${tagNum}|wifi_mac|${wifiMac}" | /opt/uit-toolbox/parse

	# System Model Name
	tOneProductName=$(dmidecode --string system-product-name)
	printf '%s' "system_data|${tagNum}|system_model|${tOneProductName}" | /opt/uit-toolbox/parse

	# System UUID
	tOneUUID=$(dmidecode --string system-uuid)
	printf '%s' "system_data|${tagNum}|system_uuid|${tOneUUID}" | /opt/uit-toolbox/parse

	# System SKU
	tOneSKU=$(dmidecode --string system-sku-number)
	printf '%s' "system_data|${tagNum}|system_sku|${tOneSKU}" | /opt/uit-toolbox/parse

	# Chassis Type
	tThreeType=$(dmidecode --string chassis-type | head -n1)
	printf '%s' "system_data|${tagNum}|chassis_type|${tThreeType}" | /opt/uit-toolbox/parse

	# CPU Manufacturer
	tFourManufacturer=$(dmidecode --string processor-manufacturer)
	printf '%s' "system_data|${tagNum}|cpu_manufacturer|${tFourManufacturer}" | /opt/uit-toolbox/parse

	# CPU Model
	tFourVersion=$(dmidecode --string processor-version)
	printf '%s' "system_data|${tagNum}|cpu_model|${tFourVersion}" | /opt/uit-toolbox/parse

	# CPU Max Speed
	tFourMaxSpeed=$(dmidecode -t4 | grep 'Max Speed' | sed 's/[^0-9]//g')
	printf '%s' "system_data|${tagNum}|cpu_maxspeed|${tFourMaxSpeed}" | /opt/uit-toolbox/parse

	# CPU Core Count
	tFourCoreCount=$(dmidecode -t4 | grep 'Core Count' | sed 's/Core Count: //g' | sed 's/^[[:space:]]*//g')
	printf '%s' "system_data|${tagNum}|cpu_cores|${tFourCoreCount}" | /opt/uit-toolbox/parse

	# CPU Thread Count
	tFourThreadCount=$(dmidecode -t4 | grep 'Thread Count' | sed 's/Thread Count: //g' | sed 's/^[[:space:]]*//g')
	printf '%s' "system_data|${tagNum}|cpu_threads|${tFourThreadCount}" | /opt/uit-toolbox/parse

	# Motherboard Manufacturer
	tTwoManufacturer=$(dmidecode --string baseboard-manufacturer)
	printf '%s' "system_data|${tagNum}|motherboard_manufacturer|${tTwoManufacturer}" | /opt/uit-toolbox/parse

	# Motherboard Serial
	tTwoSerialNumber=$(dmidecode --string baseboard-serial-number)
	printf '%s' "system_data|${tagNum}|motherboard_serial|${tTwoSerialNumber}" | /opt/uit-toolbox/parse

	# System Manufacturer
	tOneManufacturer=$(dmidecode --string system-manufacturer)
	printf '%s' "system_data|${tagNum}|system_manufacturer|${tOneManufacturer}" | /opt/uit-toolbox/parse
}

function hardwareData {
# 53 cols in art
terminalCols=$(( $(tput cols) / 2 ))
# 5 rows in art, first number in tput cup
terminalRows=$(( $(tput lines) / 2 ))
if [[ $(tput cols) -gt 66 && $(tput lines) -gt 25 ]]; then
tput reset
printf '%s\n' "${BOLD}"
printf '%s\n' "${RED}"
tput cup 1 0
cat <<'EOF'
  _    _       _                    _ _             
 | |  | |     (_)                  (_) |            
 | |  | |_ __  ___   _____ _ __ ___ _| |_ _   _     
 | |  | | '_ \| \ \ / / _ \ '__/ __| | __| | | |    
 | |__| | | | | |\ V /  __/ |  \__ \ | |_| |_| |    
  \____/|_| |_|_| \_/ \___|_|  |___/_|\__|\__, |    
        / _| | |  | |               | |    __/ |    
   ___ | |_  | |__| | ___  _   _ ___| |_ _|___/ __  
  / _ \|  _| |  __  |/ _ \| | | / __| __/ _ \| '_ \ 
 | (_) | |   | |  | | (_) | |_| \__ \ || (_) | | | |
  \___/|_|   |_|  |_|\___/ \__,_|___/\__\___/|_| |_|                 
EOF

printf '%s\n' "${RESET}"
printf '%s\n' "${BOLD}"
tput cup 12 0
cat <<'EOF'
-----------------------------------------------------

  ___       __ _                         _         
 / __| ___ / _| |___ __ ____ _ _ _ ___  | |__ _  _ 
 \__ \/ _ \  _|  _\ V  V / _` | '_/ -_) | '_ \ || |
 |___/\___/_|  \__|\_/\_/\__,_|_| \___| |_.__/\_, |
                                              |__/ 
   ___                               ___             _    _       
  / __|__ _ _ __  ___ _ _ ___ _ _   | _ \__ _ ___ __| |_ | |_____ 
 | (__/ _` | '  \/ -_) '_/ _ \ ' \  |   / _` (_-</ _| ' \| / / -_)
  \___\__,_|_|_|_\___|_| \___/_||_| |_|_\__,_/__/\__|_||_|_\_\___|
EOF
printf '%s\n' "${RESET}"
printf '%s\n' "${BOLD}Inputting data into database...${RESET}"
fi
	printf '%s' "general|host_connected|1|${UUID}" | /opt/uit-toolbox/parse
	### DMI Data
	#t0 = BIOS
	#t1 = system
	#t2 = Base Board/Motherboard
	#t3 = Chassis
	#t4 = Processor
	#t22 = Battery
	#t32 = Boot Status
	biosVersion=$(dmidecode --string bios-version)
		printf '%s' "general|bios_version|${biosVersion}|${UUID}" | /opt/uit-toolbox/parse
		printf '%s' "client_health|${tagNum}|bios_version|${biosVersion}" | /opt/uit-toolbox/parse
	biosDate=$(dmidecode --string bios-release-date)
		printf '%s' "general|bios_date|${biosDate}|${UUID}" | /opt/uit-toolbox/parse
	biosFirmwareRev=$(dmidecode --string firmware-revision)
		printf '%s' "general|bios_firmware|${biosFirmwareRev}|${UUID}" | /opt/uit-toolbox/parse
	systemSerial=$(dmidecode --string system-serial-number)
		printf '%s' "general|system_serial|${systemSerial}|${UUID}" | /opt/uit-toolbox/parse

	###Disk Data
	diskData

	###Battery Data
	if [[ -f /sys/class/power_supply/BAT0/charge_full_design ]]; then
		batChargeNow=$(cat /sys/class/power_supply/BAT0/charge_full)
		batChargeFactory=$(cat /sys/class/power_supply/BAT0/charge_full_design)
		batHealthPCNT=$(( batChargeNow * 100 / batChargeFactory ))
			printf '%s' "general|battery_health|${batHealthPCNT}|${UUID}" | /opt/uit-toolbox/parse
		batChargeCycles=$(cat /sys/class/power_supply/BAT0/cycle_count)
			printf '%s' "general|battery_charge_cycles|${batChargeCycles}|${UUID}" | /opt/uit-toolbox/parse
	elif [[ -f /sys/class/power_supply/BAT1/energy_full_design ]]; then
		batChargeNow=$(cat /sys/class/power_supply/BAT1/energy_full)
		batChargeFactory=$(cat /sys/class/power_supply/BAT1/energy_full_design)
		batHealthPCNT=$(( batChargeNow * 100 / batChargeFactory ))
			printf '%s' "general|battery_health|${batHealthPCNT}|${UUID}" | /opt/uit-toolbox/parse
		batChargeCycles=$(cat /sys/class/power_supply/BAT1/cycle_count)
			printf '%s' "general|battery_charge_cycles|${batChargeCycles}|${UUID}" | /opt/uit-toolbox/parse
	fi
	
	batteryModel=$(dmidecode -t22 | grep 'Name' | sed 's/Name: //g' | sed 's/^[[:space:]]*//g')
	if [[ -z $batteryModel ]]; then
		if [[ -f /sys/class/power_supply/BAT0/model_name ]]; then
			batteryModel=$(cat /sys/class/power_supply/BAT0/model_name)
		elif [[ -f /sys/class/power_supply/BAT1/model_name ]]; then
			batteryModel=$(cat /sys/class/power_supply/BAT1/model_name)
		fi
	fi
		printf '%s' "general|battery_model|${batteryModel}|${UUID}" | /opt/uit-toolbox/parse
	
	batteryCapacity=$(dmidecode -t22 | grep 'Design Capacity' | sed 's/[^0-9]//g')
		printf '%s' "general|battery_capacity|${batteryCapacity}|${UUID}" | /opt/uit-toolbox/parse

	batterySerial=$(dmidecode -t22 | grep 'SBDS Serial Number' | sed 's/SBDS Serial Number: //g' | sed 's/^[[:space:]]*//g')
	if [[ -z $batterySerial ]]; then
		if [[ -f /sys/class/power_supply/BAT0/serial_number ]]; then
			batterySerial=$(cat /sys/class/power_supply/BAT0/serial_number)
		elif [[ -f /sys/class/power_supply/BAT1/serial_number ]]; then
			batterySerial=$(cat /sys/class/power_supply/BAT1/serial_number)
		fi
	fi
		printf '%s' "general|battery_serial|${batterySerial}|${UUID}" | /opt/uit-toolbox/parse

	batteryManufacturer=$(dmidecode -t22 | grep 'SBDS Manufacture Date' | sed 's/SBDS Manufacture Date: //g' | sed 's/^[[:space:]]*//g')
		printf '%s' "general|battery_manufacturedate|${batteryManufacturer}|${UUID}" | /opt/uit-toolbox/parse

	###Memory Data
	memSerial=$(dmidecode --type memory | grep -P '\tSerial Number' | sed 's/Serial Number: //g' | tr '\n' ' ' | tr '\t' ' ' | sed 's/ Not Specified //g' | sed 's/^ //g' | tr ' ' '-' | sed 's/-$//g')
		printf '%s' "general|ram_serial|${memSerial}|${UUID}" | /opt/uit-toolbox/parse
	memCapacity=$(grep '^MemTotal' /proc/meminfo | awk '{ print $2 }')
		printf '%s' "general|ram_capacity|${memCapacity}|${UUID}" | /opt/uit-toolbox/parse
	memSpeed=$(dmidecode --type 17 | grep '^[[:space:]]*Speed\:' | head -n1 | sed 's/[^0-9]'//g)
		printf '%s' "general|ram_speed|${memSpeed}|${UUID}" | /opt/uit-toolbox/parse

	###Boot Times
	bootTime=$(systemd-analyze | grep -oP '[0-9]+[0-9.]*' | head -n 1)
		printf '%s' "general|boot_time|${bootTime}|${UUID}" | /opt/uit-toolbox/parse

	###CPU Info
	for i in $(find /sys/class/hwmon/ -mindepth 1); do
    type=$(cat ${i}/name)
    if [[ $type == "coretemp" ]]; then
        cpuTemp=$(cat ${i}/temp1_input)
		printf '%s' "general|cpu_temp|${cpuTemp}|${UUID}" | /opt/uit-toolbox/parse
        fi
	done

	printf '%s' "system-stats|cpu|${UUID}" | /opt/uit-toolbox/parse
	printf '%s' "system-stats|network|${UUID}" | /opt/uit-toolbox/parse.
}

function checkNetwork {
	while sleep 1; do
		ping -c 1 10.0.0.1 &>/dev/null
		if [[ $? == 0 ]]; then
			break
		fi
		dhclient -r
		dhclient
	done
}

function enterTag {
	tput reset
	printf '\n'

	tagNum=$(printf '%s' "SELECT tagnumber AS result FROM locations WHERE system_serial = '${systemSerial}' AND tagnumber IS NOT NULL ORDER BY time DESC LIMIT 1" | /opt/uit-toolbox/select)
	if [[ $tagNum != "NULL" ]]; then
		sqlDepartment=$(printf '%s' "SELECT department AS result FROM locations WHERE system_serial = '${systemSerial}' AND department IS NOT NULL ORDER BY time DESC LIMIT 1" | /opt/uit-toolbox/select)
		UUID=""
		UUID=$(printf '%s' "${sqlDepartment}-"; cat /proc/sys/kernel/random/uuid)

		printf '%s' "init|${UUID}|${tagNum}|${systemSerial}|${etherAddr}|${wifiMac}|$(cat /sys/class/tpm/tpm0/tpm_version_major)" | /opt/uit-toolbox/parse
		coproc uit_cpu { uit-cpu 2>/dev/null; }
		coproc uit_network { uit-network 2>/dev/null; }
		coproc uit_sql { uit-sql 2>/dev/null; }
		return
	else
		read -p "${BOLD}Please enter the ${GREEN}6-digit tag number${RESET} ${BOLD}followed by ${GREEN}Enter${RESET}${BOLD}:${RESET} " tagNum
		printf '\n'

		UUID=$(printf '%s' "newEntry-"; cat /proc/sys/kernel/random/uuid)

		printf '%s' "init|${UUID}|${tagNum}|${systemSerial}|${etherAddr}|${wifiMac}|$(cat /sys/class/tpm/tpm0/tpm_version_major)" | /opt/uit-toolbox/parse
		printf '%s' "location|custom|${tagNum}|${systemSerial}|new entry|0|" | /opt/uit-toolbox/parse
		enterTag
	fi
}



function jobInfo {
	if [[ $ACTION != "" ]]; then
		printf '%s\n' "The selected mode is ${BOLD}${ACTION}${RESET}"
	fi

	if [[ $CLIENTDISK != "" ]]; then
		printf '%s\n' "The selected disk is ${BOLD}${CLIENTDISK}${RESET}"
	fi

	if [[ $cloneMode != "" ]]; then
		printf '%s\n' "The selected clone mode is ${BOLD}${cloneMode}${RESET}"
	fi
	if [[ $cloneImgName != "" ]]; then
		printf '%s\n' "The selected image is ${BOLD}${cloneImgName}${RESET}"
	fi

	printf '\n'
}



function footer {
	biosUpdatedSQL=$(printf '%s' "SELECT bios_version AS result FROM static_bios_stats WHERE system_model = '${tOneProductName}'" | /opt/uit-toolbox/select 2>/dev/null)
	if [[ $biosUpdatedSQL == "NULL" ]]; then
		biosUpdated="$(dmidecode --string bios-version)"
	elif [[ $biosUpdatedSQL == $(dmidecode --string bios-version) ]]; then
		biosUpdated="${GREEN}Updated${RESET}"
	elif [[ $biosUpdatedSQL != $(dmidecode --string bios-version) ]]; then
		biosUpdated="${RED}Needs Update${RESET}"
	fi
	sqlLocation=$(printf '%s' "SELECT location AS result FROM locations WHERE tagnumber = '${tagNum}' ORDER BY time DESC LIMIT 1" | /opt/uit-toolbox/select 2>/dev/null)

	if [[ -d /sys/class/power_supply/BAT0 ]]; then
    batCharge=0
    batStatus=""
    batCharge=$(cat /sys/class/power_supply/BAT0/capacity)
    batStatus=$(cat /sys/class/power_supply/BAT0/status)
	elif [[ -d /sys/class/power_supply/BAT1 ]]; then
		batCharge=$(cat /sys/class/power_supply/BAT0/capacity)
		batStatus=$(cat /sys/class/power_supply/BAT0/status)
	else
		batCharge="0"
	fi

	sqlOS=$(printf '%s' "SELECT os_name AS result FROM client_health WHERE tagnumber = '${tagNum}'" | /opt/uit-toolbox/select 2>/dev/null)
	batCharge=${GREEN}${batCharge}${RESET}
	tput reset
	lines=$(tput lines)
	tput cup $(( lines - 4 )) 0
	tput el
	printf '%s%s %s%s\n' "Tag: ${tagNum}, Serial: ${systemSerial}, Location: \"${sqlLocation}\", Time:" $(date "+%m/%d/%y") $(date "+%r") "${RESET}"
	tput cup $(( lines - 3 )) 0
	tput el 
	printf '%s\n' "Battery: ${GREEN}${batCharge}%${RESET}, BIOS: ${biosUpdated}${RESET}, OS: ${BLUE}${sqlOS}${RESET}"
	tput cup $(( lines - 2 )) 0
	tput el
	printf '%s\n' "${DIM}UIT-Toolbox Client by ${RESET}Cameron Raschke${DIM} (caraschke@uh.edu). ${RESET}${RED}Go coogs!!${RESET}"
	tput cup 1 0
}



function header {
	footer
	printf '%s\n' "${RESET}Welcome to UIT-Toolbox Client by Cameron Raschke ${DIM}(caraschke@uh.edu).${RESET}"
	printf '\n'
	tput bold
	tput setaf 1
	printf '%s\n' "| |    | |  | |     | |"
	printf '%s\n' "| |    | |  | |_____| |"
	printf '%s\n' "| |    | |  | |_____| |"
	printf '%s\n' "| |____| |  | |     | |"
	printf '%s\n' "\________/  | |     | |"
	tput sgr0
	printf '\n'
	printf '%s\n' "------------------------------"
}



function manualClient {
	header
	printf '%s\n' "${BOLD}-General best practices${RESET} "
	printf '   %s\n' "* Sanitize laptops with cleaner before imaging them."
	printf '   %s\n' "* Reset BIOS to default/factory settings before imaging."
	printf '%s\n' "${BOLD}-Dells${RESET} "
	printf '   %s\n' "* Make sure SATA mode is in AHCI mode and not RAID mode."
	printf '   %s\n' "   * This is usually under \"System Configuration\" or \"Storage\" in BIOS."
	printf '\n'
	printf '%s\n' "${BOLD}Please remove the thumb drive and select one of the following options:${RESET} "
	printf '   %s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}Image ${DIM}(server -> laptop)${RESET} ${BOLD}an HP laptop${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}Image ${DIM}(server -> laptop)${RESET} ${BOLD}a Dell laptop${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[3]${RESET} ${BOLD}Simple erase ${RESET}${DIM}(NVMe, SSD, or HDD)${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[9]${RESET} ${BOLD}Other options${RESET} ${DIM}(advanced)${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[0]${RESET} ${BOLD}Enter Location${RESET}"
	read -n 1 -p "${BOLD}Please enter [0-9]:${RESET} " mainMenuOpt
}





function powerWarning {
	if [[ $CLIENTDISK =~ $NVME_REGEX ]]; then
		return
	fi
	jobInfo
	footer
	printf '%s\n' "${BOLD}${RED}*** WARNING ***${RESET}"
	printf '%s\n' "${BOLD}It is highly recommended to put the computer into hibernate mode. This takes less than 5 seconds.${RESET}"
	printf '%s\n' "${BOLD}${RED}*** WARNING ***${RESET}"
	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}Hibernate (recommended)${RESET}"
	printf '%s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}Skip hibernate${RESET}"
	read -n 1 -p  "${BOLD}Please enter [1-2]:${RESET} " restartBool
	if [[ $restartBool == "1" ]]; then
		jobInfo
		footer
		rtcwake --mode mem --seconds 3
		checkNetwork
		jobInfo
		footer
	elif [[ $restartBool == "2" ]]; then
		jobInfo
		footer
		printf '%s\n' "${BOLD}${RED}*** WARNING ***${RESET}"
		printf '%s\n' "${BOLD}It is dangerous to skip this step.${RESET}"
		printf '%s\n' "${BOLD}${RED}*** WARNING ***${RESET}"
		printf '\n'
		read -p "Press ${BOLD}${RED}Enter${RESET} to skip this step and NOT hibernate ${RED}(DANGEROUS)${RESET}.... "
		jobInfo
		footer
	else
		powerWarning
	fi
}



function appSelect {
	footer
	printf '%s\n' "${BOLD}Please select an ${BLUE}action${RESET}${BOLD}:${RESET} "
	printf '\n'
	printf '   %s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}erase and clone${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}only erase (advanced)${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[3]${RESET} ${BOLD}only clone${RESET}"
	read -n 1 -p "${BOLD}Please enter [1-3]:${RESET} " APPSELECT
	if [[ $APPSELECT == "1" ]]; then
		APPSELECT="EC"
		ACTION="erase and clone"
		powerWarning
	elif [[ $APPSELECT == "2" ]]; then
		APPSELECT="E"
		ACTION="erase"
		powerWarning
	elif [[ $APPSELECT == "3" ]]; then
		APPSELECT="C"
		ACTION="clone"
	else
		printf '\n'
		printf '%s\n' "${BOLD}${RED}Please enter a valid number [1-3].${RESET}"
		sleep 0.5
		appSelect
	fi
}



function basicEraseMode_Shred {
	if [[ $shredMode == 'verify' ]]; then
		shredMode='verify'
		RMODE='Verify Mode'
		PCNTOFSECTOR='30'
	else
		shredMode='autodetect'
		RMODE='Autodetect'
		if [[ $shredMode == 'autodetect' ]]; then
			if [[ $CLIENTDISK =~ $SSD_REGEX ]]; then
				PCNTOFSECTOR="30"
				shredMode='zero'
				RMODE='Zero Mode'
			elif [[ $CLIENTDISK =~ $NVME_REGEX ]]; then
				shredMode='nist'
				RMODE='NIST 800-88r1 Mode'
			else
				PCNTOFSECTOR="30"
				shredMode='zero'
				RMODE='Zero Mode'
			fi
		fi
	fi
	printf '%s' "general|erase_mode|${RMODE}|${UUID}" | /opt/uit-toolbox/parse
}



function advEraseMode_Shred {
	footer

	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}Autodetect${RESET} (Default)
	-Best trade off between security and speed. Autodetects the best mode for your disk."

	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}NIST 800-88r1${RESET}
	-Fastest for NVME."

	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[3]${RESET} ${BOLD}Zero Mode + Quick Verify${RESET}
	-One pass of zeroes, quick verification step."
	
	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[4]${RESET} ${BOLD}DOD 5220.22-M/NCSC-TG-025/AFSSI-5020/HMG IS5${RESET}
	-Writes a pass of zeroes, then ones, then a random bit. Verifies each step."

	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[5]${RESET} ${BOLD}RCMP TSSIT OPS-II/VSITR${RESET}
	-Alternates between 0's and 1's 6 times. 7th pass writes and verifies a random bit."

	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[6]${RESET} ${BOLD}Schneier${RESET}
	-A pass of 1's then a pass of 0's. Five passes of a random pattern of characters."

	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[7]${RESET} ${BOLD}Gutmann${RESET}
	-Four random character passes, 27 predefined pattern passes, four more random character passes."
	
	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[8]${RESET} ${BOLD}Verify Only${RESET}
	-Does not write data, choose character/pattern to verify."

	printf '\n'
	printf '%s\n' "${BOLD}${GREEN}[9]${RESET} ${BOLD}Unlock${RESET}
	-Unlocks disks previously locked by this program."

	printf '\n'
	read -n 1 -p "${BOLD}Please select an option [0-9]:${RESET} " MODESELECT
	printf '\n'

	case $MODESELECT in
	1)
	shredMode='autodetect'
	RMODE='Autodetect'
	basicEraseMode_Shred
	;;
	2)
	shredMode='nist'
	RMODE='NIST 800-88r1 Mode'
	;;
	3)
	shredMode='zero'
	RMODE='Zero Mode'
	;;
	4)
	shredMode='dod'
	RMODE='DOD 5220.22-M/NCSC-TG-025/AFSSI-5020/HMG IS5 Mode'
	;;
	5)
	shredMode='rcmp'
	RMODE='RCMP TSSIT OPS-II/VSITR Mode'
	;;
	6)
	shredMode='schneier'
	RMODE='Schneier Mode'
	;;
	7)
	shredMode='gutmann'
	RMODE='Gutmann Mode'
	;;
	8)
	shredMode='verify'
	RMODE='Verify Mode'
	;;
	9)
	shredMode='unlock'
	RMODE='Unlock Mode'
	;;
	*)
	modeselect
	;;
	esac

	tput reset
	footer
	read -p "Are you sure you want to use ${BOLD}${BLUE}${RMODE}${RESET} on ${BOLD}${BLUE}${CLIENTDISK}${RESET}? Press ${BOLD}${GREEN}Enter${RESET} to continue...${RESET} "

	printf '%s' "general|erase_mode|${RMODE}|${UUID}" | /opt/uit-toolbox/parse
}



function diskSelect {
	footer
	diskList=$(lsblk --nodeps --noheadings -o NAME,SIZE --exclude 1,2,7,11)
	diskNames=$(printf '%s\n' "${diskList}" | awk '{print $1}')
	CLIENTDISK=""
	diskCount="0"
	local a="0"
	local n="0"
	local diskArr=()

	for i in ${diskNames}; do
		diskCount=$(( diskCount + 1 ))
		diskArr+=( "$i" )
	done

	if [[ $diskCount == "1" ]]; then
		for i in ${!diskArr[@]}; do
			CLIENTDISK=${diskArr[$i]}
		done
		printf '%s\n' "${BOLD}The disk ${BLUE}${CLIENTDISK}${RESET} ${BOLD}has been automatically selected because it is the only detected disk."
		read -n 1 -p "Press ${BOLD}${GREEN}[1]${RESET} ${BOLD}to confirm:${RESET} " input
		if [[ $input != "1" ]]; then
			printf '%s\n' "${BOLD}${RED}Reselecting disk.${RESET}"
			sleep 0.5
			diskSelect
		fi
	else
		printf '%s\n' "${BOLD}Which disk do you want to ${BLUE}${ACTION}${RESET}${BOLD}?"
		while read -r line; do
			a=$(( a + 1 ))
			printf '%s\n' "${BOLD}${GREEN}[${a}]${RESET} $line"
		done < <(printf '%s\n' "${BOLD}${diskList}${RESET}")

		printf '\n'
		read -n 1 -p "${BOLD}Please select [1-$a]:${RESET} " CLIENTDISK
		for i in ${!diskArr[@]}; do
			n=$(( $n + 1 ))
			if [[ $n == $CLIENTDISK ]]; then
				CLIENTDISK=${diskArr[$i]}
			fi
		done
		printf '\n'
		printf '\n'
	fi
	
	if [[ $CLIENTDISK =~ ${NVME_REGEX} || $CLIENTDISK =~ ${SSD_REGEX} ]]; then
		printf '%s' "general|disk|${CLIENTDISK}|${UUID}" | /opt/uit-toolbox/parse
	else
	    printf '\n'
	    printf '%s\n' "${BOLD}${RED}Invalid disk regex check.${RESET}"
		sleep 0.5
	    diskSelect
	fi	
}



function randBit_Shred {
	RANDBIT=$(cat /dev/urandom | xxd -plain | head -1 | cut -c 1)
}



function randPattern_Shred {
	RANDPATTERN=$(cat /dev/urandom | xxd -plain | head -1 | cut -c 8)
}



function writeDisk_Shred {
	printf '%s' "remote|${tagNum}|status|Erasing disk ($shredMode)" | /opt/uit-toolbox/parse
	if [[ -z $writeSections ]]; then
		writeSections='1000'
	fi

	if [[ -z $PCNTOFSECTOR ]]; then
		PCNTOFSECTOR='100'
	fi

	if [[ -z $CHAR ]]; then
		CHAR='0'
	fi

	if [[ -z $WMODE ]]; then
		WMODE='zero'
	fi
	
	if [[ $WMODE == "zero" ]]; then
		SOURCE='cat /dev/zero'
		BITS='null bits'
	fi

	if [[ $WMODE == "random" ]]; then
		SOURCE='cat /dev/urandom'
		BITS='random bits'
	fi

	if [[ $WMODE == "randBit_Shred" ]]; then
		randBit_Shred
		SOURCE="yes \"${RANDBIT}\""
		BITS="a random bit (${RANDBIT})"
	fi

	if [[ "$WMODE" == 'randPattern_Shred' ]]; then
		randPattern_Shred
		SOURCE="yes \"${RANDPATTERN}\""
		BITS="a random pattern (${RANDPATTERN})"
	fi

	if [[ "$WMODE" == 'char' ]]; then
		SOURCE="yes \"${CHAR}\""
		BITS="\"${CHAR}\""
	fi

	BS='512'
	diskBytes=$(blockdev --getsize64 /dev/${CLIENTDISK})
	sectorSize=$((diskBytes / BS / writeSections))

	printf '%s\n' "Filling ${PCNTOFSECTOR}% of ${CLIENTDISK} with a stream of ${BITS}...."
	printf '%s' "general|erase_diskpercent|${PCNTOFSECTOR}|${UUID}" | /opt/uit-toolbox/parse

	if [[ $PCNTOFSECTOR == '100' ]]; then
		${SOURCE} | (pv > /dev/${CLIENTDISK})
		return 0
	fi
	
	i=0
	while [[ $i -lt $writeSections ]]; do
		i=$((i + 1))
		tput cuu1
		tput el
		printf '%s\n' "Writing to section ${i}/${writeSections}"
		if (( $i % 25 == 0 )); then
			printf '%s' "remote|${tagNum}|status|Writing to section ${i}/${writeSections} ($shredMode)" | /opt/uit-toolbox/parse
		fi
		sectorMin=$((i * sectorSize))
		sectorMax=$((sectorMin + sectorSize))
		sectorDiff=$((sectorMax - sectorMin))
		COUNT=$((sectorDiff / 100 * PCNTOFSECTOR))
		randSector=$(shuf -i ${sectorMin}-$((sectorMax - COUNT)) -n 1)

		SKIP=$(shuf -i ${randSector}-${sectorMax} -n 1)
    	${SOURCE} | dd bs=${BS} count=${COUNT} seek=${SKIP} of=/dev/${CLIENTDISK} iflag=fullblock status=none 2>/dev/null
	done

	printf '\n'
	printf '%s\n' "Completely filling the first sector...."
    ${SOURCE} | dd bs=${BS} count=${COUNT} seek=0 of=/dev/${CLIENTDISK} iflag=fullblock status=none 2>/dev/null
	printf '%s\n' "Completely filling the last sector...."
	${SOURCE} | dd bs=${BS} count=${COUNT} seek=$(( ${sectorCount} - 1 )) of=/dev/${CLIENTDISK} iflag=fullblock status=none 2>/dev/null
}



function vrfyDisk_Shred {
	printf '%s' "remote|${tagNum}|status|Verifying erase ($shredMode)" | /opt/uit-toolbox/parse
	if [[ -z $vrfySections ]]; then
		vrfySections='1000'
	fi

	if [[ -z $PCNTOFSECTOR ]]; then
		PCNTOFSECTOR='100'
	fi

	BS='512'
	diskBytes=$(blockdev --getsize64 /dev/${CLIENTDISK})
	sectorSize=$((diskBytes / BS / vrfySections))
	PROCFAIL='0'
	i='0'

	if [[ -z $CHAR ]]; then
		CHAR='0'
	fi

	printf '%s\n' "Looking for non-${CHAR}'s on ${CLIENTDISK}...."

	if [[ $PCNTOFSECTOR == '100' ]]; then
		printf '%s' "remote|${tagNum}|status|Verifying the entire disk" | /opt/uit-toolbox/parse
		if [[ $(pv /dev/${CLIENTDISK} | xxd -p | grep --quiet -m 1 "[^${CHAR}]"; printf '%s' ${PIPESTATUS[2]}) == '0' ]]; then
		    PROCFAIL='1'
			printf '%s' "remote|${tagNum}|status|fail - verifying erase" | /opt/uit-toolbox/parse
            read -t 10 -p "${BOLD}${RED}Verification test failed${RESET}${BOLD}. Press ${GREEN}Enter${RESET}${BOLD}..."
			pkill --terminal tty1
		else
        	printf '%s\n' "${BOLD}The drive ${CLIENTDISK} is completely and securely wiped.${RESET}"
			PROCFAIL='0'
		fi
	fi
	
	i=0
	while [[ $i -lt $vrfySections && $PROCFAIL == '0' ]]; do
		i=$((i + 1))
		tput cuu1
		tput el
		printf '%s\n' "Verifying section ${i}/${vrfySections}"
		if (( $i % 25 == 0 )); then
			printf '%s' "remote|${tagNum}|status|Verifying section ${i}/${vrfySections}" | /opt/uit-toolbox/parse
		fi
		sectorMin=$((i * sectorSize))
		sectorMax=$((sectorMin + sectorSize))
		sectorDiff=$((sectorMax - sectorMin))
		COUNT=$((sectorDiff / 100 * PCNTOFSECTOR))
		randSector=$(shuf -i ${sectorMin}-$((sectorMax - COUNT)) -n 1)


		SKIP=$(shuf -i ${randSector}-${sectorMax} -n 1)
    	if [[ $(dd if=/dev/${CLIENTDISK} bs=${BS} count=${COUNT} skip=${SKIP} iflag=fullblock status=none 2>/dev/null \
        	| xxd -p | grep --quiet -m 1 "[^${CHAR}]"; printf '%s' ${PIPESTATUS[2]}) == '0' ]]; then
            	PROCFAIL='1'
				printf '%s' "remote|${tagNum}|status|fail - verifying erase" | /opt/uit-toolbox/parse
            	read -t 10 -p "${BOLD}${RED}Verification test failed${RESET}${BOLD}. Press ${GREEN}Enter${RESET}${BOLD}..."
				pkill --terminal tty1
    	fi

	done

	printf '\n'
	printf '%s\n' "Verifing the first sector of the disk...."
		printf '%s' "remote|${tagNum}|status|Verifing the first sector of the disk..." | /opt/uit-toolbox/parse
	if [[ $(dd if=/dev/${CLIENTDISK} count=${sectorCount} skip=0 iflag=fullblock status=none 2>/dev/null \
        | xxd -p | grep --quiet -m 1 "[^${CHAR}]"; printf '%s' ${PIPESTATUS[2]}) == '0'  ]]; then
            	PROCFAIL='1'
				printf '%s' "remote|${tagNum}|status|fail - verifying erase" | /opt/uit-toolbox/parse
            	read -t 10 -p "${BOLD}${RED}Verification test failed${RESET}${BOLD}. Press ${GREEN}Enter${RESET}${BOLD}..."
				pkill --terminal tty1
    fi
	printf '%s\n' "Verifing the last sector of the disk...."
		printf '%s' "remote|${tagNum}|status|Verifing the last sector of the disk..." | /opt/uit-toolbox/parse
    if [[ $(dd if=/dev/${CLIENTDISK} count=${sectorCount} skip=$(( ${sectorCount} - 1 )) \
		iflag=fullblock status=none 2>/dev/null \
        | xxd -p | grep --quiet -m 1 "[^${CHAR}]"; printf '%s' ${PIPESTATUS[2]}) == '0' ]]; then
            	PROCFAIL='1'
				printf '%s' "remote|${tagNum}|status|fail - verifying erase" | /opt/uit-toolbox/parse
				read -t 10 -p "${BOLD}${RED}Verification test failed${RESET}${BOLD}. Press ${GREEN}Enter${RESET}${BOLD}..."
				pkill --terminal tty1
    fi

    printf '%s\n' "${PCNTOFSECTOR}% of ${CLIENTDISK} has been verified."
	printf '%s' "remote|${tagNum}|status|${PCNTOFSECTOR}% of ${CLIENTDISK} has been verified." | /opt/uit-toolbox/parse
	if [[ $PROCFAIL == '0' ]]; then
		printf '%s\n' "Test passed successfully!"
		return 0
	else
		printf '%s' "remote|${tagNum}|status|fail - verifying erase" | /opt/uit-toolbox/parse
		read -t 10 -p "${BOLD}${RED}Verification test failed${RESET}${BOLD}. Press ${GREEN}Enter${RESET}${BOLD}..."
		pkill --terminal tty1
	fi
}



function secErase_Shred {
	printf '%s' "remote|${tagNum}|status|Using secure erase on ${CLIENTDISK}" | /opt/uit-toolbox/parse
	footer
	if [[ $CLIENTDISK =~ $SSD_REGEX ]]; then 
		printf '%s\n' "Using Secure Erase on ${CLIENTDISK}. This can take a while, please keep the device powered on...."
		if [[ /dev/${CLIENTDISK} ]]; then
			hdparm --user-master u --security-set-pass UHouston /dev/${CLIENTDISK} &>/dev/null
			hdparm --user-master u --security-erase UHouston /dev/${CLIENTDISK} &>/dev/null
		fi
	elif [[ $CLIENTDISK =~ $NVME_REGEX ]]; then
		printf '%s\n' "Using Secure Erase on ${CLIENTDISK:0:-2}. This can take a while, please keep the device powered on...."
		if [[ /dev/${CLIENTDISK:0:-2} ]]; then
			nvme format /dev/${CLIENTDISK:0:-2} --ses=1 --namespace-id=1 &>/dev/null
			nvme format /dev/${CLIENTDISK:0:-2} --ses=2 --namespace-id=1 &>/dev/null
		fi
	else
		printf '%s' "remote|${tagNum}|status|fail - secure erase" | /opt/uit-toolbox/parse
		read -t 10 -p "No compatible SATA or NVME drive is selected. Can't use Secure Erase on ${CLIENTDISK}."
		pkill --terminal tty1
	fi
}



function secUnlock_Shred {
	printf '%s' "remote|${tagNum}|status|Unlocking ${CLIENTDISK}" | /opt/uit-toolbox/parse
	footer
	if [[ $CLIENTDISK =~ $SSD_REGEX ]]; then 
		printf '%s\n' "Unlocking ${CLIENTDISK}, please keep the device powered on...."
		if [[ /dev/${CLIENTDISK} ]]; then
			hdparm --user-master u --security-unlock UHouston /dev/${CLIENTDISK} &>/dev/null
			hdparm --user-master u --security-disable UHouston /dev/${CLIENTDISK} &>/dev/null
		fi
	elif [[ $CLIENTDISK =~ $NVME_REGEX ]]; then
		printf '%s\n' "NVME drives do not need to be unlocked. Continuing...."
	else
		printf '%s' "remote|${tagNum}|status|fail - secure unlock" | /opt/uit-toolbox/parse
		read -t 10 -p "No compatible SATA or NVME drive is selected. Can't unlock ${CLIENTDISK}."
		pkill --terminal tty1
	fi
}



function nistMode_Shred {
	footer
	printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BOLD}${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	
	printf '\n'
	printf '\n'
	printf '%s\n' "Step [1/2]:"
	PCNTOFSECTOR='20'
	WMODE='random'
	writeDisk_Shred
	
	printf '\n'
	printf '%s\n' "Step [2/3]:"
	secErase_Shred
	secUnlock_Shred
	
	printf '\n'
	printf '%s\n' "Step [3/3]:"
	PCNTOFSECTOR='10'
	CHAR='0'
	vrfyDisk_Shred
}



function zeroMode_Shred {
	footer
	printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	
	printf '\n'
	printf '\n'	
	WMODE='zero'
	CHAR='0'
	if [[ $diskType == "hdd" ]]; then
		PCNTOFSECTOR="10"
		printf '%s\n' "Step [1/1]: "
		writeDisk_Shred
	else
		printf '%s\n' "Step [1/1]: "
		writeDisk_Shred
		# printf '\n'
		# printf '%s\n' "Step [2/2]: "
		# vrfyDisk_Shred
	fi
}



function dodMode_Shred {
	footer
	printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	
	printf '\n'
	printf '\n'
	printf '%s\n' "Step [1/6]: "
	printf '\n'
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred
	
	printf '\n'
	printf '%s\n' "Step [2/6]: "
	printf '\n'
	PCNTOFSECTOR='100'
	CHAR='0'
	vrfyDisk_Shred

	printf '\n'
	printf '%s\n' "Step [3/6]: "
	printf '\n'
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred
	
	printf '\n'
	printf '%s\n' "Step [4/6]: "
	printf '\n'
	PCNTOFSECTOR='100'
	CHAR='1'
	vrfyDisk_Shred

	printf '\n'
	printf '%s\n' "Step [5/6]: "
	printf '\n'
	WMODE='randBit_Shred'
	PCNTOFSECTOR='100'
	writeDisk_Shred
	
	printf '\n'
	printf '%s\n' "Step [6/6]: "
	printf '\n'
	PCNTOFSECTOR='100'
	CHAR=${RANDBIT}
	vrfyDisk_Shred
}



function rcmpMode_Shred {
	footer
	printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	
	printf '\n'
	printf '\n'
	printf '%s\n' "Step [1/8]: "
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [2/8]: "
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [3/8]: "
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred
	
	printf '\n'
	printf '%s\n' "Step [4/8]: "
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [5/8]: "
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [6/8]: "
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [7/8]: "
	printf '\n'
	WMODE='randBit_Shred'
	PCNTOFSECTOR='100'
	writeDisk_Shred
	
	printf '\n'
	printf '%s\n' "Step [8/8]: "
	printf '\n'
	PCNTOFSECTOR='100'
	CHAR="${RANDBIT}"
	vrfyDisk_Shred
}



function schneierMode_Shred {
	footer
	printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	
	printf '\n'
	printf '\n'
	printf '%s\n' "Step [1/7]: "
	WMODE='char'
	PCNTOFSECTOR='100'
	CHAR='1'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [2/7]: "
	WMODE='zero'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [3/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [4/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [5/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [6/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred

	printf '\n'
	printf '%s\n' "Step [7/7]: "
	WMODE='rand'
	PCNTOFSECTOR='100'
	writeDisk_Shred
}



function gutmann {
	n='0'
	GUTMANNARRAY=(01010101 10101010 10010010 01001001 00100100 00000000 00010001 00100010)
	GUTMANNARRAY+=(00110011 01000100 01010101 01100110 01110111 10001000 10011001 10101010)
	GUTMANNARRAY+=(10111011 11001100 11011101 11101110 11111111 10010010 01001001 00100100)
	GUTMANNARRAY+=(01101101 10110110 11011011)

	footer
	printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	
	printf '\n'
	printf '\n'	
	while [[ $n -le 35 ]]; do 

		if [[ $n -le 4 ]]; then
			printf '%s\n' "[${n}/35] Writing \"${RANDPATTERN}\" to ${CLIENTDISK}"
			WMODE='randPattern_Shred'
			PCNTOFSECTOR='100'
			writeDisk_Shred
		fi

		if [[ $n -le 31 && $n -gt 4 ]]; then
			WMODE='char'
			PCNTOFSECTOR='100'
			for i in ${GUTMANNARRAY[@]}; do
				RANDNUM=$(shuf -i 1-26 -n 1)
				CHAR=${GUTMANARRAY[$RANDNUM]}
			done
			printf '%s\n' "[${n}/35] Writing pattern ${CHAR} to ${CLIENTDISK}"
			writeDisk_Shred
		fi

		if [[ $n -gt 31 ]]; then
			printf '%s\n' "[${n}/35] Writing \"${RANDPATTERN}\" to ${CLIENTDISK}"
			WMODE='randPattern_Shred'
			PCNTOFSECTOR='100'
			writeDisk_Shred
		fi

	done
}



function verifyMode_Shred {
	footer
	if [[ $unattended == 'true' ]]; then
		shredMode='verify'
		VRFYMODE='vfast'
		input='0'
	else
		printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BLUE}${RMODE}${RESET}${BOLD}. Verifying disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"

		printf '\n'
		printf '\n'
		printf '%s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}Full verification (Default)${RESET}
		-Longest, verifies every bit on the disk"

		printf '\n'
		printf '%s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}Moderate verification${RESET}
		-10000 divisions, 75% verified"

		printf '\n'
		printf '%s\n' "${BOLD}${GREEN}[3]${RESET} ${BOLD}Medium verification${RESET}
		-5000 divisions, 50% verified"

		printf '\n'
		printf '%s\n' "${BOLD}${GREEN}[4]${RESET} ${BOLD}Fast verification${RESET}
		-2500 divisions, 25% verified"

		printf '\n'
		printf '%s\n' "${BOLD}${GREEN}[5]${RESET} ${BOLD}Very fast verification${RESET}
		-1000 divisions, 10% verified"

		printf '\n'
		read -n 1 -p "${BOLD}Please select ${GREEN}[1-5]${RESET}${BOLD}:${RESET} " VRFYSELECT
		printf '\n'

		case $VRFYSELECT in
		1)
		VRFYMODE='full'
		;;
		2)
		VRFYMODE='moderate'
		;;
		3)
		VRFYMODE='medium'
		;;
		4)
		VRFYMODE='fast'
		;;
		5)
		VRFYMODE='vfast'
		;;
		*)
		printf '\n'
		printf '\n'
		printf '%s\n' "${BOLD}Incorrect input selected, please try again${RESET}"
		sleep 0.5
		verifyMode_Shred
		;;
		esac

		printf '\n'
		read -p "Which character/pattern would you like to verify?: " input
	fi
	
	if [[ $VRFYMODE == 'full' ]]; then
		PCNTOFSECTOR='100'
		CHAR="${input}"
	fi

	if [[ $VRFYMODE == 'moderate' ]]; then
		vrfySections='10000'
		PCNTOFSECTOR='75'
		CHAR="${input}"
	fi

	if [[ $VRFYMODE == 'medium' ]]; then
		vrfySections='5000'
		PCNTOFSECTOR='50'
		CHAR="${input}"
	fi

	if [[ $VRFYMODE == 'fast' ]]; then
		vrfySections='2500'
		PCNTOFSECTOR='25'
		CHAR="${input}"
	fi

	if [[ $VRFYMODE == 'vfast' ]]; then
		vrfySections='1000'
		PCNTOFSECTOR='10'
		CHAR="${input}"
	fi

	footer
	printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BLUE}${VRFYMODE}${RESET}${BOLD} verify mode. ${BLUE}${PCNTOFSECTOR}%${RESET}${BOLD} of ${BLUE}${CLIENTDISK}${RESET}${BOLD} is being verified.${RESET}"

	vrfyDisk_Shred
}



function unlockMode_Shred {
	footer
	printf '%s\n' "${BOLD}UIT-Toolbox Client running in ${BLUE}${RMODE}${RESET}${BOLD}. Erasing disk ${BLUE}${CLIENTDISK}${RESET}${BOLD}.${RESET}"
	
	printf '\n'
	printf '\n'
	secUnlock_Shred
}



function clientselect_Clone {
	footer
	printf '%s\n' "${BOLD}Please select a ${BOLD}${BLUE}clone mode${RESET}${BOLD}: "
	printf '   %s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}Restore${RESET} ${DIM}(server -> client)${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}Save${RESET} ${DIM}(client -> server)${RESET}"
	read -n1 -p "${BOLD}Enter [1-2]:${RESET} " cloneMode
	printf '\n'
	printf '\n'
	case $cloneMode in
		1)
			cloneMode="restoredisk"
		;;
		2)
			cloneMode="savedisk"
		;;
		*)
			printf '%s\n' "${BOLD}${RED}Error - Invalid input${RESET}"
		;;
	esac

	printf '%s\n' "${BOLD}Select which ${BOLD}${BLUE}image${RESET} you are cloning:${RESET} "
	printf '   %s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}Tech Commons HP laptops${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}Tech Commons Dell laptops${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[3]${RESET} ${BOLD}Tech Commons Dell desktops${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[4]${RESET} ${BOLD}Tech Commons Dell print kiosk laptops${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[5]${RESET} ${BOLD}SHRL Dell desktops${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[6]${RESET} ${BOLD}ITSC Team Leads desktops${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[7]${RESET} ${BOLD}Ubuntu Desktop${RESET}"
	read -n1 -p "${BOLD}Enter [1-6]:${RESET} " CLIENTTYPE
	printf '\n'
	case $CLIENTTYPE in
	1)
	cloneImgName='TechCommons-HP-LaptopsLZ4'
	;;
	2)
	cloneImgName='TechCommons-Dell-Laptops'
	;;
	3)
	cloneImgName='TechCommons-Dell-Desktops'
	;;
	4)
	cloneImgName='TechCommons-Dell-HelpDesk'
	;;
	5)
	cloneImgName='SHRL-Dell-Desktops'
	;;
	6)
	cloneImgName='TechCommons-Dell-Desktop-Team-Leads'
	;;
	7)
	cloneImgName='Ubuntu-Desktop'
	;;
	*)
	clientselect_Clone
	;;
	esac
}



function execute_Clone {
	printf '%s' "general|clone_image|${cloneImgName}|${UUID}" | /opt/uit-toolbox/parse
	printf '%s' "remote|${tagNum}|status|Cloning ${cloneImgName} -> ${CLIENTDISK} ($cloneMode)" | /opt/uit-toolbox/parse
	printf '%s' "0" > /root/uptime
	printf '%s' "0" > /tmp/cpu-usage.txt
	printf '%s' "0" > /tmp/network-usage.txt
	SECONDS=0
	start_time=$SECONDS
	linuxServer="10.0.0.1"
	linuxDNS="mickey.uit"
	umount /home/partimag 2>/dev/null
	mkdir -p /home/partimag
	if [[ $cloneMode == "restoredisk" ]]; then
		mount -t nfs -o ro ${linuxServer}:/srv/nfs/uit-toolbox/${linuxPath} /home/partimag
		footer
		sleep 1
		/usr/sbin/ocs-sr --language en_US.UTF-8 --postaction command --user-mode beginner \
			-k1 --skip-check-restorable-r ${cloneMode} ${cloneImgName} ${CLIENTDISK}
	fi
	if [[ $cloneMode == "savedisk" ]]; then
		mount -t nfs ${linuxServer}:/srv/nfs/uit-toolbox/${linuxPath} /home/partimag
		footer
		sleep 1
		/usr/sbin/ocs-sr --language en_US.UTF-8 --postaction command --user-mode beginner \
			--skip-enc-ocs-img --skip-fsck-src-part --use-partclone -z8 ${cloneMode} ${cloneImgName} ${CLIENTDISK}
	fi
	cloneElapsed=$(( SECONDS - start_time))
	printf '%s' "general|clone_time|${cloneElapsed}|${UUID}" | /opt/uit-toolbox/parse
	umount /home/partimag 2>/dev/null
	return
}



function execute_Shred {
	if [[ $APPSELECT == "EC" || $APPSELECT == "E" ]]; then
		SECONDS=0
		start_time=$SECONDS
		if [[ $shredMode == 'nist' ]]; then
			nistMode_Shred
		fi

		if [[ $shredMode == 'zero' ]]; then
			zeroMode_Shred
		fi

		if [[ $shredMode == 'dod' ]]; then
			dodMode_Shred
		fi

		if [[ $shredMode == 'rcmp' ]]; then
			rcmpMode_Shred
		fi
	
		if [[ $shredMode == 'gutmann' ]]; then
			gutmann
		fi
	
		if [[ $shredMode == 'schneier' ]]; then
			schneierMode_Shred
		fi
	
		if [[ $shredMode == 'verify' ]]; then
			verifyMode_Shred
		fi

		if [[ $shredMode == 'unlock' ]]; then
			unlockMode_Shred
		fi
		shredElapsed=$(( SECONDS - start_time ))
		printf '%s' "general|erase_time|${shredElapsed}|${UUID}" | /opt/uit-toolbox/parse
	fi
	return
}



function execute {
	printf '%s' "0" > /root/uptime
	printf '%s' "0" > /tmp/cpu-usage.txt
	printf '%s' "0" > /tmp/network-usage.txt

	printf '%s' "remote|${tagNum}|job_active|TRUE" | /opt/uit-toolbox/parse

	if [[ $cloneMode == "savedisk" && ($APPSELECT == "E" || $APPSELECT == "EC") ]]; then
		printf '%s' "remote|${tagNum}|status|fail - Can't erase master image" | /opt/uit-toolbox/parse
		read -t 10 -p "${BOLD}Cannot erase device and save its image.${RESET}"
		pkill --terminal tty1
	fi

	if [[ $APPSELECT == "EC" ]]; then
		if [[ -z $cloneMode ]]; then
			clientselect_Clone
		fi
		if [[ $job_queued != "hpEraseAndClone" ]]; then
			printf '%s' "remote|${tagNum}|job_queued|generic-erase+clone" | /opt/uit-toolbox/parse
		fi
		basicEraseMode_Shred
		printf '%s' "remote|${tagNum}|clone_mode|$cloneMode" | /opt/uit-toolbox/parse
		printf '%s' "remote|${tagNum}|erase_mode|$shredMode" | /opt/uit-toolbox/parse
		execute_Shred
		execute_Clone
	elif [[ $APPSELECT == "E" ]]; then
		if [[ -z $shredMode ]]; then
			advEraseMode_Shred
		else
			basicEraseMode_Shred
		fi
		if [[ $job_queued != "nvmeErase" ]]; then
			printf '%s' "remote|${tagNum}|job_queued|generic-erase" | /opt/uit-toolbox/parse
		fi
		printf '%s' "remote|${tagNum}|erase_mode|$shredMode" | /opt/uit-toolbox/parse
		execute_Shred
	elif [[ $APPSELECT == "C" ]]; then
		if [[ -z $cloneMode ]]; then
			clientselect_Clone
		fi
		if [[ $job_queued != "hpCloneOnly" ]]; then
			printf '%s' "remote|${tagNum}|job_queued|generic-clone" | /opt/uit-toolbox/parse
		fi
		printf '%s' "remote|${tagNum}|clone_mode|$cloneMode" | /opt/uit-toolbox/parse
		execute_Clone
	else
		printf '%s' "remote|${tagNum}|job_active|FALSE" | /opt/uit-toolbox/parse
		printf '%s' "remote|${tagNum}|job_queued|" | /opt/uit-toolbox/parse
		printf '%s' "remote|${tagNum}|status|fail - Invalid application selected" | /opt/uit-toolbox/parse
		read -t 10 -p "${BOLD}${RED}Error - Invalid application selected.${RESET}"
		pkill --terminal tty1
	fi

}


function totaltime {
	totalElapsed=$(printf '%s' $(( (shredElapsed + cloneElapsed) / 60 )))
}


function terminate {
	printf '%s' "remote|${tagNum}|job_queued|" | /opt/uit-toolbox/parse
	printf '%s' "remote|${tagNum}|job_active|FALSE" | /opt/uit-toolbox/parse
	printf '%s' "remote|${tagNum}|status|Waiting for job" | /opt/uit-toolbox/parse
	printf '%s' "system-stats|cpu|${UUID}" | /opt/uit-toolbox/parse
	printf '%s' "system-stats|network|${UUID}" | /opt/uit-toolbox/parse
	printf '%s' "0" > /root/uptime
	printf '%s' "0" > /tmp/cpu-usage.txt
	printf '%s' "0" > /tmp/network-usage.txt
	
	footer
	totaltime

	diskData

	for i in $(ps | grep 'uit-cpu' | awk '{ print $1 }'); do kill "${i}" 2>/dev/null; done
	for i in $(ps | grep 'uit-network' | awk '{ print $1 }'); do kill "${i}" 2>/dev/null; done


	imgUpdate=$(printf '%s' "SELECT time AS result FROM jobstats WHERE clone_master = TRUE ORDER BY time DESC LIMIT 1" | /opt/uit-toolbox/select)
	imgUpdate=${imgUpdate::10}

	cloneNumToday=$(printf '%s' "SELECT COUNT(tagnumber) AS result FROM jobstats WHERE clone_completed = TRUE AND time > '${DATE} 00:00:00.000'" | /opt/uit-toolbox/select)

	eraseNumToday=$(printf '%s' "SELECT COUNT(tagnumber) AS result FROM jobstats WHERE erase_completed = TRUE AND time > '${DATE} 00:00:00.000'" | /opt/uit-toolbox/select)

	clientCloneTotal=$(printf '%s' "SELECT COUNT(tagnumber) AS result FROM jobstats WHERE clone_completed = TRUE AND tagnumber = '${tagNum}'" | /opt/uit-toolbox/select)

	jobsToday=$(( cloneNumToday + eraseNumToday ))

	if [[ $APPSELECT == "C" || $APPSELECT == "EC" ]]; then
		if [[ $cloneMode == "restoredisk" ]]; then

			if [[ $cloneMode == "restoredisk" && $APPSELECT == "EC" ]]; then
				terminateAction="Erased and cloned"
			fi

			if [[ $cloneMode == "restoredisk" && $APPSELECT == "C" ]]; then
				terminateAction="Cloned"
			fi

			printf '%s' "general|clone_completed|1|${UUID}" | /opt/uit-toolbox/parse

			if [[ $APPSELECT == "EC" ]]; then
				printf '%s' "general|erase_completed|1|${UUID}" | /opt/uit-toolbox/parse
			fi

			terminateMessage=$(printf '%s\n' "Tag#: ${tagNum}"
			printf '%s\n' "MAC: ${etherAddr}"
			printf '%s\n' "Action: ${terminateAction}"
			printf '%s\n' "Total time taken: ${totalElapsed} minutes"
			printf '%s\n' "Server: \"${linuxDNS}\""
			printf '%s\n' "Image: \"${cloneImgName}\""
			printf '%s\n' "Total jobs today: ${jobsToday}"
			)
		fi
		if [[ $cloneMode == "savedisk" ]]; then
			printf '%s' "general|clone_master|1|${UUID}" | /opt/uit-toolbox/parse
			printf '%s' "general|clone_completed|1|${UUID}" | /opt/uit-toolbox/parse

			terminateMessage=$(printf '%s\n' "Tag#: ${tagNum}"
			printf '%s\n' "MAC: ${etherAddr}"
			printf '%s\n' "Action: ${terminateAction}"
			printf '%s\n' "Total time taken: ${totalElapsed} minutes"
			printf '%s\n' "Server: \"${linuxDNS}\""
			printf '%s\n' "Image: \"${cloneImgName}\""
			printf '%s\n' "Total jobs today: ${jobsToday}"
			)
		fi
	fi
	

	if [[ $APPSELECT == "E" ]]; then
		printf '%s' "general|erase_completed|1|${UUID}" | /opt/uit-toolbox/parse

		terminateAction="erased"

		terminateMessage=$(printf '%s\n' "Tag#: ${tagNum}"
		printf '%s\n' "MAC: ${etherAddr}"
		printf '%s\n' "Action: ${terminateAction}"
		printf '%s\n' "Total time taken: ${totalElapsed} minutes"
		printf '%s\n' "Total jobs today: ${jobsToday}"
		)		
	fi

	if [[ $mainMenuOpt != 0 ]]; then
		/usr/bin/play /root/oven.mp3 &> /dev/null
	fi
	footer
	printf '%s\n' "${BOLD}Process has finished!${RESET}"
	printf '\n'
	printf '\n'
	printf '%s\n' "${terminateMessage}"
	printf '\n'
	printf '\n'
	read -p "${BOLD}Process has finished. Press ${GREEN}Enter${RESET}${BOLD} to shutdown...${RESET} "
	poweroff
}

function resetForClientRestart {
	printf '%s' "remote|${tagNum}|job_queued|" | /opt/uit-toolbox/parse
	printf '%s' "remote|${tagNum}|job_active|FALSE" | /opt/uit-toolbox/parse
	for i in $(ps | grep 'uit-cpu' | awk '{ print $1 }'); do kill "${i}" 2>/dev/null; done
	for i in $(ps | grep 'uit-network' | awk '{ print $1 }'); do kill "${i}" 2>/dev/null; done
	for i in $(ps | grep 'uit-sql' | awk '{ print $1 }'); do kill "${i}" 2>/dev/null; done
	dpkg --purge uit-toolbox-client
	rm -r /root/uit-toolbox-client*
	rm -r /root/.ssh/known_hosts*
	printf '%s' "0" > /root/uptime
	printf '%s' "0" > /tmp/cpu-usage.txt
	printf '%s' "0" > /tmp/network-usage.txt
	pkill --terminal tty1
}

function autodetectClient {
	footer
	if [[ $(printf '%s' "${tOneManufacturer}" | grep -i "dell") ]]; then
		systemManufacturer="dell"
		cloneImgName='TechCommons-Dell-Laptops'
		elif [[ $(printf '%s' "${tOneManufacturer}" | grep -i "hp") ]]; then
			systemManufacturer="hp"
			cloneImgName='TechCommons-HP-LaptopsLZ4'
		elif [[ $(printf '%s' "${tOneManufacturer}" | grep -i "hewlett") ]]; then
			systemManufacturer="hp"
			cloneImgName='TechCommons-HP-LaptopsLZ4'
		else
			systemManufacturer="unknown"
			cloneImgName='TechCommons-HP-LaptopsLZ4'
	fi

	if [[ $(printf '%s' "${tThreeType}" | grep -i "notebook") ]]; then
		chassisType="notebook"
		elif [[ $(printf '%s' "${tThreeType}" | grep -i "desktop") ]]; then
			chassisType="desktop"
		else
			chassisType="unknown"
	fi

	while true; do
		ACTION=""
		CLIENTDISK=""
		cloneMode=""
		header
		printf '\n'
		printf '\n'

		sql=$(printf '%s' "SELECT tagnumber AS result FROM remote WHERE tagnumber = '${tagNum}' AND status NOT like 'fail%'" | /opt/uit-toolbox/select)
		if [[ $sql == $tagNum ]]; then
			printf '%s' "remote|${tagNum}|status|Waiting for job" | /opt/uit-toolbox/parse
		fi

		unattended="true"

		remote
		if [[ $job_queued != "NULL" ]]; then
			tput cuu1
			tput el
			while true; do
				header
				printf '\n'
				printf '\n'
				tput cuu1
				tput el
				remote
				if [[ $job_queued == "NULL" ]]; then
					break
				fi
				if [[ $job_queued_override == "NULL" ]]; then
					printf '%s' "remote|${tagNum}|job_active|TRUE" | /opt/uit-toolbox/parse
					break
				fi
				if [[ $job_available == "NULL" && $job_queued_position == 1 ]]; then
					okay_to_go=$(printf '%s' "SELECT COUNT(tagnumber) AS result FROM remote WHERE job_queued IN ('hpEraseAndClone', 'hpCloneOnly', 'generic-erase+clone', 'generic-clone') AND job_active = TRUE" | /opt/uit-toolbox/select)
					if [[ $okay_to_go == "NULL" || $okay_to_go == "0" ]]; then
						printf '%s' "remote|${tagNum}|job_active|TRUE" | /opt/uit-toolbox/parse
						break
					fi
				fi
				printf '%s\n' "	${BOLD}Tagnumber ${tagNum} (${systemSerial}) is scheduled for ${job_queued_formatted} and is ${job_queued_position} in queue. Press ${BOLD}${GREEN}'q' ${RESET}${BOLD}to exit.${RESET}"
				printf '%s' "remote|${tagNum}|status|Scheduled for ${job_queued_formatted}, ${job_queued_position} in queue." | /opt/uit-toolbox/parse
				read -t 3 -N 1 input
				if [[ $input = "q" ]] || [[ $input = "Q" ]]; then
					printf '%s' "0" > /root/uptime
					printf '%s' "0" > /tmp/cpu-usage.txt
					printf '%s' "0" > /tmp/network-usage.txt
					printf '%s' "remote|${tagNum}|job_queued|" | /opt/uit-toolbox/parse
					printf '%s' "remote|${tagNum}|job_active|FALSE" | /opt/uit-toolbox/parse
					pkill --terminal tty1
				fi
			done
			if [[ $job_queued == "data collection" ]]; then
				enterTag
				systemData
				hardwareData
				printf '%s' "remote|${tagNum}|status|Starting data collection" | /opt/uit-toolbox/parse
				resetForClientRestart
			elif [[ $job_queued == "update" ]]; then
				enterTag
				systemData
				hardwareData
				printf '%s' "remote|${tagNum}|status|Updating..." | /opt/uit-toolbox/parse
				rm /root/uit-toolbox-client.deb
				while [[ ! -f /root/uit-toolbox-client.deb ]]; do
					curl http://mickey.uit:8080/client/pkg/uit-toolbox-client.deb --output /root/uit-toolbox-client.deb &>/dev/null
					sleep 1
				done
				dpkg --install /root/uit-toolbox-client.deb &>/dev/null
				resetForClientRestart
			elif [[ $job_queued == "findmy" ]]; then
				printf '%s' "remote|${tagNum}|status|Playing sound" | /opt/uit-toolbox/parse
				play /root/findmy1.mp3 &> /dev/null
				resetForClientRestart
			elif [[ $job_queued == "hpEraseAndClone" ]]; then
				enterTag
				systemData
				hardwareData
				printf '%s' "remote|${tagNum}|status|Starting Erase + Clone job (HP)" | /opt/uit-toolbox/parse
				APPSELECT="EC"
				ACTION="erase and clone"
				if [[ /dev/nvme0n1 ]]; then
					CLIENTDISK='nvme0n1'
				else
					printf '%s' "remote|${tagNum}|status|fail - Disk doesn't exist" | /opt/uit-toolbox/parse
					autodetectClient
				fi
					printf '%s' "general|disk|${CLIENTDISK}|${UUID}" | /opt/uit-toolbox/parse
				cloneMode="restoredisk"
				shredMode="autodetect"
				RMODE="Autodetect"
					printf '%s' "general|erase_mode|${RMODE}|${UUID}" | /opt/uit-toolbox/parse
				linuxServer="10.0.0.1"
				linuxDNS="mickey.uit"
				footer
				rtcwake --mode mem --seconds 3
				checkNetwork
				footer
				execute
				totaltime
				printf '%s' "general|clone_completed|1|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "general|erase_completed|1|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "system-stats|cpu|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "system-stats|network|${UUID}" | /opt/uit-toolbox/parse
				resetForClientRestart
			elif [[ $job_queued == "hpCloneOnly" ]]; then
				enterTag
				systemData
				hardwareData
				printf '%s' "remote|${tagNum}|status|Starting Clone only job (HP)" | /opt/uit-toolbox/parse
				APPSELECT="C"
				ACTION="clone"
				if [[ /dev/nvme0n1 ]]; then
					CLIENTDISK='nvme0n1'
				else
					printf '%s' "remote|${tagNum}|status|fail - disk doesn't exist" | /opt/uit-toolbox/parse
					autodetectClient
				fi
					printf '%s' "general|disk|${CLIENTDISK}|${UUID}" | /opt/uit-toolbox/parse
				cloneMode="restoredisk"
				linuxServer="10.0.0.1"
				linuxDNS="mickey.uit"
				footer
				rtcwake --mode mem --seconds 3
				checkNetwork
				footer
				execute
				totaltime
				printf '%s' "general|clone_completed|1|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "system-stats|cpu|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "system-stats|network|${UUID}" | /opt/uit-toolbox/parse
				resetForClientRestart
			elif [[ $job_queued == "nvmeErase" ]]; then
				enterTag
				systemData
				hardwareData
				if [[ /dev/nvme0n1 ]]; then
					CLIENTDISK='nvme0n1'
				else
					printf '%s' "remote|${tagNum}|status|fail - disk doesn't exist" | /opt/uit-toolbox/parse
					autodetectClient
				fi
					printf '%s' "general|disk|${CLIENTDISK}|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "remote|${tagNum}|status|Starting NVME Erase job (${CLIENTDISK})" | /opt/uit-toolbox/parse
				vrfySections="1000"
				writeSections="1000"
				PCNTOFSECTOR='10'
				CHAR='0'
				APPSELECT="E"
				ACTION="erase"
				shredMode="autodetect"
				RMODE="Autodetect"
					printf '%s' "general|erase_mode|${RMODE}|${UUID}" | /opt/uit-toolbox/parse
				footer
				rtcwake --mode mem --seconds 3
				checkNetwork
				footer
				execute
				totaltime
				printf '%s' "general|erase_completed|1|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "system-stats|cpu|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "system-stats|network|${UUID}" | /opt/uit-toolbox/parse
				resetForClientRestart
			elif [[ $job_queued == "nvmeVerify" ]]; then
				enterTag
				systemData
				hardwareData
				printf '%s' "remote|${tagNum}|status|Starting Verify job (${CLIENTDISK})" | /opt/uit-toolbox/parse
				vrfySections=""
				writeSections=""
				PCNTOFSECTOR='10'
				CHAR='0'
				APPSELECT="E"
				ACTION="erase"
				if [[ /dev/nvme0n1 ]]; then
					CLIENTDISK='nvme0n1'
				else
					printf '%s' "remote|${tagNum}|status|fail - disk doesn't exist" | /opt/uit-toolbox/parse
					autodetectClient
				fi
					printf '%s' "general|disk|${CLIENTDISK}|${UUID}" | /opt/uit-toolbox/parse
				shredMode="verify"
				RMODE="Verify Mode"
					printf '%s' "general|erase_mode|${RMODE}|${UUID}" | /opt/uit-toolbox/parse
				footer
				rtcwake --mode mem --seconds 3
				checkNetwork
				footer
				execute
				totaltime
				printf '%s' "general|erase_completed|1|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "system-stats|cpu|${UUID}" | /opt/uit-toolbox/parse
				printf '%s' "system-stats|network|${UUID}" | /opt/uit-toolbox/parse
				resetForClientRestart
			elif [[ $job_queued == "shutdown" ]]; then
				printf '%s' "remote|${tagNum}|status|fail - Shutting down" | /opt/uit-toolbox/parse
				printf '%s' "remote|${tagNum}|job_queued|" | /opt/uit-toolbox/parse
				printf '%s' "remote|${tagNum}|job_active|FALSE" | /opt/uit-toolbox/parse
				poweroff
			elif [[ $job_queued == "clean-shutdown" ]]; then
				printf '%s' "remote|${tagNum}|status|Shutting down" | /opt/uit-toolbox/parse
				printf '%s' "remote|${tagNum}|job_queued|" | /opt/uit-toolbox/parse
				printf '%s' "remote|${tagNum}|job_active|FALSE" | /opt/uit-toolbox/parse
				poweroff				
			elif [[ $job_queued == "fail-test" ]]; then
				printf '%s' "remote|${tagNum}|status|fail - test" | /opt/uit-toolbox/parse
				resetForClientRestart
			fi
		else
			tput cuu1
			tput el
			printf '%s\n' "	${BOLD}Tagnumber ${tagNum} (${systemSerial}) has no scheduled jobs right now. Press ${BOLD}${GREEN}'q' ${RESET}${BOLD}to continue.${RESET}"
			read -t 3 -N 1 input
			if [[ $input = "q" ]] || [[ $input = "Q" ]]; then
				break
			fi
		fi
	done

	unattended="false"
	header
	printf '%s\n' "${BOLD}${BLUE}Autodetect mode${RESET}${BOLD} will destroy all data on this laptop and image it."
	printf '\n'
	printf '%s\n' "------------------------------"
	printf '%s\n' "${BOLD}Select mode:${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}Autodetect${RESET}"
	printf '   %s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}Manual${RESET}"
	read -n 1 -p "${BOLD}Enter [1,2]:${RESET} " input

	if [[ $input == "1" ]]; then
		if [[ $systemManufacturer == "hp" && $chassisType == "notebook" && $diskType == "nvme" ]]; then
			mainMenuOpt="1"
		elif [[ $systemManufacturer == "dell" && $chassisType == "notebook" && $diskType == "nvme" ]]; then
			mainMenuOpt="2"
		else
			printf '\n'
			printf '%s\n' "${BOLD}${RED}Not enough info for autodetect.${RESET}"
			sleep 0.5
			manualClient
		fi
		printf '\n'
		printf '%s\n' "------------------------------"
		printf '%s\n' "${BOLD}Is this information corect?${RESET}"
		printf '\n'
		printf '%s\n' "${BOLD}${BLUE}System Manufacturer${RESET}${BOLD}: ${systemManufacturer}${RESET}"
		printf '%s\n' "${BOLD}${BLUE}Chassis Type${RESET}${BOLD}: ${chassisType}${RESET}"
		printf '%s\n' "${BOLD}${BLUE}Disk type${RESET}${BOLD}: ${DISK}${RESET}"
		printf '\n'
		printf '%s\n' "${BOLD}${GREEN}[1]${RESET} ${BOLD}Yes, it is correct${RESET}"
		printf '%s\n' "${BOLD}${GREEN}[2]${RESET} ${BOLD}No, start over${RESET}"
		read -n 1 -p "${BOLD}Please enter [1,2]:${RESET} " input
		if [[ $input == "1" ]]; then
				return
			else
				autodetectClient
		fi
		else
			manualClient
	fi
}


function main {
	tput reset
	enterTag
	systemData
	hardwareData
	tput reset
	autodetectClient
	curl "https://10.0.0.1:1411/api/refresh-client.php?password=UIT_DB_CLIENT_PASSWD&tagnumber=${tagNum}"
	if [[ $mainMenuOpt == "1" ]]; then
		APPSELECT="EC"
		ACTION="erase and clone"
		if [[ /dev/nvme0n1 ]]; then
			CLIENTDISK='nvme0n1'
		else
			diskSelect
		fi
			printf '%s' "general|disk|${CLIENTDISK}|${UUID}" | /opt/uit-toolbox/parse
		cloneMode="restoredisk"
		cloneImgName="TechCommons-HP-LaptopsLZ4"
		shredMode="autodetect"
		RMODE="autodetect"
			printf '%s' "general|erase_mode|${RMODE}|${UUID}" | /opt/uit-toolbox/parse
		linuxServer="10.0.0.1"
		linuxDNS="mickey.uit"
		powerWarning
		execute
	elif [[ $mainMenuOpt == "2" ]]; then
		APPSELECT="EC"
		ACTION="erase and clone"
		if [[ /dev/nvme0n1 ]]; then
			CLIENTDISK='nvme0n1'
		else
			diskSelect
		fi
			printf '%s' "general|disk|${CLIENTDISK}|${UUID}" | /opt/uit-toolbox/parse
		cloneMode="restoredisk"
		cloneImgName="TechCommons-Dell-Laptops"
		shredMode="autodetect"
		RMODE="autodetect"
			printf '%s' "general|erase_mode|${RMODE}|${UUID}" | /opt/uit-toolbox/parse
		linuxServer="10.0.0.1"
		linuxDNS="mickey.uit"
		powerWarning
		execute
	elif [[ $mainMenuOpt == "3" ]]; then
		APPSELECT="E"
		ACTION="erase"
		diskSelect
			printf '%s' "general|disk|${CLIENTDISK}|${UUID}" | /opt/uit-toolbox/parse
		shredMode="autodetect"
		RMODE="autodetect"
			printf '%s' "general|erase_mode|${RMODE}|${UUID}" | /opt/uit-toolbox/parse
		powerWarning
		execute
	elif [[ $mainMenuOpt == "9" ]]; then
		appSelect
		if [[ $APPSELECT != "battery" ]]; then
			diskSelect
			execute
		else
			appSelect
		fi
	elif [[ $mainMenuOpt == "0" ]]; then
		:
	else
		pkill --terminal tty1
	fi
	if [[ $unattended == "false" ]]; then
		printf '%s' "remote|${tagNum}|job_active|FALSE" | /opt/uit-toolbox/parse
		terminate
	fi
}

main
