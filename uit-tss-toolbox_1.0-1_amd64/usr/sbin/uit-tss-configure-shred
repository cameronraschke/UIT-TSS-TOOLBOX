#!/bin/bash

if [ ! -f /opt/live-build.deb ]; then
/usr/bin/apt purge live-build -y
/usr/bin/wget http://ftp.us.debian.org/debian/pool/main/l/live-build/live-build_20220505_all.deb \
	--output-document=/opt/debian-live.deb
/usr/bin/apt install /opt/debian-live.deb -y
fi

/usr/bin/apt install dosfstools -y

rm -r /opt/UIT-TSS-SHRED/
mkdir /opt/UIT-TSS-SHRED/

( cd /opt/UIT-TSS-SHRED/ && \

	lb clean && \

	/usr/bin/lb config \
		--apt apt \
		--apt-recommends true \
		--apt-secure true \
		--apt-source-archives true \
		--architecture amd64 \
		--archive-areas 'main' \
		--binary-filesystem fat32 \
		--binary-images iso-hybrid \
		--bootappend-live "boot=live live-media=removable toram username=root hostname=UIT-TSS-SHRED \
			timezone=America/Chicago" \
		--bootloaders "grub-efi syslinux" \
		--chroot-filesystem squashfs \
		--compression gzip \
		--clean \
		--debian-installer live \
		--debian-installer-distribution bullseye \
		--distribution bullseye \
		--debootstrap-options "--variant=minbase --arch=amd64" \
		--hdd-label UIT-TSS-SHRED \
		--image-name UIT-TSS-SHRED \
		--initramfs live-boot \
		--initsystem systemd \
		--iso-application UIT-TSS-SHRED \
		--iso-preparer "Cameron Raschke caraschke@uh.edu" \
		--iso-publisher "Cameron Raschke caraschke@uh.edu" \
		--iso-volume UIT-TSS-SHRED \
		--mode debian \
		--system live \
		--uefi-secure-boot enable \
		--updates true)

mkdir -p /opt/UIT-TSS-SHRED/config/bootloaders
cp -r /usr/share/live/build/bootloaders/isolinux /opt/UIT-TSS-SHRED/config/bootloaders
cp -r /usr/share/live/build/bootloaders/grub-pc /opt/UIT-TSS-SHRED/config/bootloaders

cat <<'EOF' > /opt/UIT-TSS-SHRED/config/bootloaders/isolinux/isolinux.cfg
UI vesamenu.c32

MENU TITLE Boot Menu
DEFAULT linux
        TIMEOUT 10
        MENU RESOLUTION 640 480
        SAY Now booting into UIT-TSS-SHRED by Cameron Raschke
label linux
        menu label UIT-TSS-SHRED by Cameron Raschke
        menu default
        linux /live/vmlinuz
        initrd /live/initrd.img
        append @APPEND_LIVE@
EOF

rm -r /opt/UIT-TSS-SHRED/config/bootloaders/grub-pc/*
cat <<'EOF' > /opt/UIT-TSS-SHRED/config/bootloaders/grub-pc/grub.cfg
insmod part_gpt
insmod part_msdos
insmod fat
insmod iso9660
insmod gfxterm

set gfxmode=800x600
terminal_output gfxterm

set default="0"
set timeout=0
set timeout_style=hidden

menuentry "UIT-TSS-SHRED by Cameron Raschke" {
        linux @KERNEL_LIVE@ @APPEND_LIVE@
        initrd @INITRD_LIVE@
}
EOF

cat <<'EOF' > /opt/UIT-TSS-SHRED/config/package-lists/live.list.chroot
live-boot
live-config
live-config-systemd
systemd-sysv
openssl
less
nano
vim
cifs-utils
passwd
locales
firmware-linux-free
parted
gdisk
libasound2
libasound2-plugins
alsa-utils
sox
libsox-fmt-all
kbd
iptables
hdparm
util-linux
nvme-cli
procps
coreutils
pv
EOF

mkdir -p /opt/UIT-TSS-SHRED/config/includes.chroot/root/
cat <<'EOF' > /opt/UIT-TSS-SHRED/config/hooks/live/0100-uit-tss-toolbox-setup.hook.chroot

/usr/sbin/sysctl -w "net.ipv6.conf.all.disable_ipv6=1" &>/dev/null
/usr/sbin/sysctl -w "net.ipv6.conf.default.disable_ipv6=1" &>/dev/null
/usr/sbin/sysctl -w "net.ipv4.conf.default.rp_filter=2" &>/dev/null
/usr/sbin/sysctl -w "net.ipv4.conf.all.rp_filter=2" &>/dev/null
/usr/sbin/sysctl -w "net.ipv4.ip_forward=0" &>/dev/null
/usr/sbin/sysctl -w "net.ipv6.conf.all.forwarding=1" &>/dev/null
/usr/sbin/sysctl -w  "net.ipv6.conf.default.forwarding=1" &>/dev/null
/usr/sbin/sysctl -p &>/dev/null

/usr/sbin/sysctl -w "kernel.printk=2 4 1 2" &>/dev/null
/usr/sbin/sysctl -w "kernel.kptr_restrict=1" &>/dev/null
/usr/sbin/sysctl -w "vm.mmap_min_addr=65536" &>/dev/null
/usr/sbin/sysctl -p &>/dev/null

echo "UIT-TSS-SHRED" > /etc/hostname
echo -e "\nWelcome to UIT-TSS-SHRED by Cameron Raschke.\n" > /etc/motd
echo -e "\nWelcome to UIT-TSS-SHRED by Cameron Raschke.\n" > /etc/issue.net
echo -e "Banner /etc/issue.net" >> /etc/ssh/sshd_config

/usr/bin/apt purge iproute2 -y &>/dev/null
EOF

chmod 777 /opt/UIT-TSS-SHRED/config/hooks/live/0100-uit-tss-toolbox-setup.hook.chroot

mkdir -p /opt/UIT-TSS-SHRED/config/includes.chroot/root/
/usr/bin/wget https://soundboardguy.com/wp-content/uploads/2022/01/Oven-Timer-Ding.mp3 \
	--output-document=/opt/UIT-TSS-SHRED/config/includes.chroot/root/oven.mp3

mkdir -p /opt/UIT-TSS-SHRED/config/includes.chroot/root
touch /opt/UIT-TSS-SHRED/config/includes.chroot/root/.bash_profile
cat <<'EOF' > /opt/UIT-TSS-SHRED/config/includes.chroot/root/.bash_profile
#!/bin/bash

clear

echo ""
echo "Configuring Kernel..."
/usr/sbin/iptables -P INPUT DROP &>/dev/null
/usr/sbin/iptables -P FORWARD DROP &>/dev/null
/usr/sbin/iptables -P OUTPUT DROP &>/dev/null
/usr/sbin/sysctl -w "net.ipv6.conf.all.disable_ipv6=1" &>/dev/null
/usr/sbin/sysctl -w "net.ipv6.conf.default.disable_ipv6=1" &>/dev/null
/usr/sbin/sysctl -w "net.ipv4.conf.default.rp_filter=2" &>/dev/null
/usr/sbin/sysctl -w "net.ipv4.conf.all.rp_filter=2" &>/dev/null
/usr/sbin/sysctl -w "net.ipv4.ip_forward=0" &>/dev/null
/usr/sbin/sysctl -w "net.ipv6.conf.all.forwarding=1" &>/dev/null
/usr/sbin/sysctl -w  "net.ipv6.conf.default.forwarding=1" &>/dev/null
/usr/sbin/sysctl -w "kernel.printk=2 4 1 2" &>/dev/null
/usr/sbin/sysctl -w "kernel.kptr_restrict=1" &>/dev/null
/usr/sbin/sysctl -w "vm.mmap_min_addr=65536" &>/dev/null
/usr/sbin/sysctl -p &>/dev/null
echo "Done."
echo ""
 
echo "Configuring audio..."
/usr/bin/amixer sset Master 100% &>/dev/null
/usr/bin/amixer set Master unmute &>/dev/null
/usr/bin/amixer sset Speakers 100% &>/dev/null
/usr/sbin/amixer set Speakers unmute &>/dev/null
echo "Done."
echo ""

echo "Configuring font..."
/usr/bin/setfont /usr/share/consolefonts/Lat7-TerminusBold16.psf.gz
echo "Done."
echo ""

sleep 1

clear

CLIENTDISK=''
SSD_REGEX='sd.*'
NVME_REGEX='nvme.*'
SCSI_REGEX='hd.*'



function intro {
	clear
	echo ""
	echo -e "\nWelcome to UIT-TSS-SHRED by Cameron Raschke.\n"
	echo "Press CTRL + C at any time to exit"
	echo "If you have exited and want to restart UIT-TSS-SHRED, press CTRL + D"
	echo ""
	echo ""
echo '
| |    | |  | |     | |
| |    | |  | |_____| |
| |    | |  | |_____| |
| |____| |  | |     | |
\________/  | |     | |
'
	echo ""
	echo "------------------------------"
	echo ""
echo 'Checklist:
	-Physical connections
	   * Make sure that power is plugged in to the client.
	   * Do not use UIT-TSS-SHRED on USB drives or drives connected over USB.
	-General best practices
	   * Sanitize laptops with cleaner before imaging them.
	   * Reset BIOS to default/factory settings before imaging.
	-Dells
	   * Make sure SATA mode is in AHCI mode and not RAID mode.
	      * This is usually under "System Configuration" or "Storage" in BIOS.
	      * Every Dell is in RAID mode by default. 
	      * If you reset BIOS, make sure you change SATA mode after the reset.
	      
	*** WARNING *** After pressing Enter, the system will enter hibernate mode.
	This is normal. Please wake up the system after it hibernates. *** WARNING ***
'
	read -p "Please remove the thumb drive and press Enter...."
	echo -n mem > /sys/power/state
	clear
}



function modeselect {
	echo ""
	echo "Choose a mode:"

	echo ""
	echo "1 NIST SP 800-88 (Default)
	-Mixture of modes"

	echo ""
	echo "2 Zero Mode + Quick Verify
	-One pass of zeroes
	-Quick verification step"
	
	echo ""
	echo "3 DOD 5220.22-M/NCSC-TG-025/AFSSI-5020/HMG IS5
	-Writes a pass of zeroes, then ones, then a random bit
	-3 passes, 3 verifications"

	echo ""
	echo "4 RCMP TSSIT OPS-II/VSITR
	-Alternates passes between 0's and 1's 6 times
	-Writes random bit, verifies random bit"

	echo ""
	echo "5 Schneier
	-A pass of 1's then a pass of 0's
	-Five passes of a random stream of characters"

	echo ""
	echo "6 Gutmann
	-Four random character passes
	-27 predefined pattern passes
	-Four random character passes"
	
	echo ""
	echo "7 Verify Only
	-Does not write data
	-Different types of verification"
	
	echo ""
	echo "8 Custom Mode
	-User chooses different options"

	echo ""
	read -n1 -p "Choose [1-7] " MODESELECT
	echo ""
	case $MODESELECT in
	1)
	MODE='default'
	RMODE='Default Mode'
	;;
	2)
	MODE='zero'
	RMODE='Zero Mode'
	;;
	3)
	MODE='dod'
	RMODE='DOD 5220.22-M/NCSC-TG-025/AFSSI-5020/HMG IS5 Mode'
	;;
	4)
	MODE='rcmp'
	RMODE='RCMP TSSIT OPS-II/VSITR Mode'
	;;
	5)
	MODE='schneier'
	RMODE='Schneier Mode'
	;;
	6)
	MODE='gutmann'
	RMODE='Gutmann Mode'
	;;
	7)
	MODE='verify'
	RMODE='Verify Mode'
	;;
	7)
	MODE='custom'
	RMODE='Custom Mode'
	;;
	*)
	modeselect
	;;
	esac
}



function diskselect {
	DISKNAMES=$(lsblk --nodeps --noheadings -o NAME --exclude 1,2,7,11)
	clear
	echo ""
	echo "The mode is: ${RMODE}"
	echo ""
    echo "These are the current disks and their sizes:"
    echo "$(lsblk --nodeps --noheadings -o NAME,SIZE --exclude 1,2,7,11)"
    echo ""
    PS3="Select a drive: "
    select CLIENTDISK in ${DISKNAMES}
    do
        if [[ $CLIENTDISK =~ sd.* || $CLIENTDISK =~ nvme.* ]]; then
		echo ""
        echo "$(lsblk /dev/${CLIENTDISK} -o NAME,SIZE,TYPE,MOUNTPOINT)"
		echo ""
        echo "You chose ${CLIENTDISK}."
        read -p "Press Enter to confirm...."
        echo ""
        break
        else
		echo "Invalid block device selected."
		echo ""
		diskselect
        exit 1
        fi
    done
}



function randquarter {
	DISKSIZEGB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 / 1000 ))
	RANDWRITESIZE=$(( ${DISKSIZEGB} / 4 ))
	/usr/bin/pv --size ${RANDWRITESIZE}g --stop-at-size < /dev/urandom > /dev/${CLIENTDISK}
}



function randhalf {
	DISKSIZEGB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 / 1000 ))
	RANDWRITESIZE=$(( ${DISKSIZEGB} / 2 ))
	/usr/bin/pv --size ${RANDWRITESIZE}g --stop-at-size < /dev/urandom > /dev/${CLIENTDISK}
}



function randfull {
	/usr/bin/pv < /dev/urandom > /dev/${CLIENTDISK}
}



function zeroquarter {
	DISKSIZEGB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 / 1000 ))
	RANDWRITESIZE=$(( ${DISKSIZEGB} / 4 ))
	/usr/bin/pv --size ${RANDWRITESIZE}g --stop-at-size < /dev/zero > /dev/${CLIENTDISK}
}



function zerohalf {
	DISKSIZEGB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 / 1000 ))
	RANDWRITESIZE=$(( ${DISKSIZEGB} / 2 ))
	/usr/bin/pv --size ${RANDWRITESIZE}g --stop-at-size < /dev/zero > /dev/${CLIENTDISK}
}



function zerofull {
	/usr/bin/pv < /dev/zero > /dev/${CLIENTDISK}
}



function charquarter {
	DISKSIZEGB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 / 1000 ))
	RANDWRITESIZE=$(( ${DISKSIZEGB} / 4 ))
	/usr/bin/yes "${SELCHAR}" | (pv > /dev/${CLIENTDISK})
}



function charhalf {
	DISKSIZEGB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 / 1000 ))
	RANDWRITESIZE=$(( ${DISKSIZEGB} / 2 ))
	/usr/bin/yes "${SELCHAR}" | (pv > /dev/${CLIENTDISK})
}



function charfull {
	/usr/bin/yes "${SELCHAR}" | (pv > /dev/${CLIENTDISK})
}



function randbit {
	RANDBIT=$(cat /dev/urandom | xxd -plain | head -1 | cut -c 1)
}



function vrfyfast {
	VRFYSECTIONS='10'
	VRFYCOUNT='500'
	VRFYCOUNTGB=$(( ${VRFYCOUNT} / 1000 ))
	VRFYBS='1000000'
	DISKSIZEMB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 ))
	DISKVRFYAMOUNT=$(( ${DISKSIZEMB} / ${VRFYSECTIONS} ))

	echo ""
	echo ""
	echo "Looking for non-${VRFYCHAR}'s on ${CLIENTDISK}...."

	DISKVERIFY1=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY2=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 1)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY3=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 2)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY4=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 3)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY5=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 4)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY6=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 5)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY7=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 6)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY8=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 7)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY9=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 8)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY10=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 9)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY=$DISKVERIFY1 && $DISKVERIFY2 && $DISKVERIFY3 && $DISKVERIFY4 && $DISKVERIFY5 && $DISKVERIFY6 && \
	$DISKVERIFY7 && $DISKVERIFY8 && $DISKVERIFY9 && $DISKVERIFY10
	
	if [[ -z $DISKVERIFY ]]; then
	VRFYFAIL='0'
        echo ""
	echo ""
        echo "${VRFYCOUNTGB}GB over ${VRFYSECTIONS} different sections of ${CLIENTDISK} have been successfully verified."
	else
	VRFYFAIL='1'
        echo ""
	echo ""
	echo "Non-zero bits found on device ${CLIENTDISK}. Test has failed."
	fi
}



function vrfymedium {
	VRFYSECTIONS='10'
	VRFYCOUNT='2000'
	VRFYCOUNTGB=$(( ${VRFYCOUNT} / 1000 ))
	VRFYBS='1000000'
	DISKSIZEMB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 ))
	DISKVRFYAMOUNT=$(( ${DISKSIZEMB} / ${VRFYSECTIONS} ))

	echo ""
	echo ""
	echo "Looking for non-${VRFYCHAR}'s on ${CLIENTDISK}...."

	DISKVERIFY1=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY2=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 1)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY3=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 2)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY4=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 3)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY5=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 4)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY6=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 5)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY7=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 6)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY8=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 7)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY9=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 8)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY10=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * 9)) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	DISKVERIFY=$DISKVERIFY1 && $DISKVERIFY2 && $DISKVERIFY3 && $DISKVERIFY4 && $DISKVERIFY5 && $DISKVERIFY6 && \
	$DISKVERIFY7 && $DISKVERIFY8 && $DISKVERIFY9 && $DISKVERIFY10
	
	if [[ -z $DISKVERIFY ]]; then
	VRFYFAIL='0'
        echo ""
	echo ""
        echo "${VRFYCOUNTGB}GB over ${VRFYSECTIONS} different sections of ${CLIENTDISK} have been successfully verified."
	else
	VRFYFAIL='1'
        echo ""
	echo ""
	echo "Non-zero bits found on device ${CLIENTDISK}. Test has failed."
	fi
}



function vrfyfull {
	DISKVERIFY=$(/usr/bin/pv /dev/${CLIENTDISK} | grep -oP -m 1 "[^${VRFYCHAR}]" | head -1)

	if [[ -z $DISKVERIFY ]]; then
        echo ""
	echo ""
        echo "The drive ${CLIENTDISK} is completely and securely wiped."
	else
        echo ""
	echo ""
	echo "Non-zero bits found on device ${CLIENTDISK}. Test has failed."
	fi
}



function vrfynist {
	VRFYSECTIONS='1000'
	VRFYCOUNT='20'
	VRFYCOUNTGB=$(( ${VRFYCOUNT} / 1000 ))
	VRFYBS='1000000'
	DISKSIZEMB=$(( $(blockdev --getsize64 /dev/${CLIENTDISK}) / 1000000 ))
	DISKVRFYAMOUNT=$(( ${DISKSIZEMB} / ${VRFYSECTIONS} ))
	i='0'

	echo ""
	echo ""
	echo "Looking for non-${VRFYCHAR}'s on ${CLIENTDISK}...."
	
	while [[ i -le 1000 ]]; do
	DISKVRFYAMOUNT=$(( ${DISKSIZEMB} / ${VRFYSECTIONS} ))
	DISKVRFY=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * ${i} )) &> /dev/null | grep -oP -m 1 [^0] | head -1)

	DISKVRFYAMOUNT=$(( ${DISKSIZEMB} / ${VRFYSECTIONS} + $(shuf -i 1-${DISKVRFYAMOUNT} -n 1) ))
	DISKVRFY=$(dd if=/dev/${CLIENTDISK} bs=${VRFYBS} count=${VRFYCOUNT} skip=$(( ${DISKVRFYAMOUNT} * ${i} )) &> /dev/null | grep -oP -m 1 [^0] | head -1)
	i=$(( $i + 1 ))

	if [[ -z $DISKVRFY ]]; then
	:
	else
	VRFYFAIL='1'
    echo ""
	echo ""
	echo "Non-zero bits found on device ${CLIENTDISK}. Test has failed."
	break
	fi
	done

	VRFYFAIL='0'
	echo ""
	echo ""
    echo "${VRFYCOUNTGB}GB over ${VRFYSECTIONS} different locations of ${CLIENTDISK} have been successfully verified."
}


function secerase {
	SSD_REGEX='sd.*'
	NVME_REGEX='nvme.*'
	SCSI_REGEX='hd.*'

	if [[ $CLIENTDISK =~ $SSD_REGEX ]]; then 
	SECERASEFAIL=0
	/usr/sbin/hdparm --user-master u --security-set-pass UHouston /dev/${CLIENTDISK} &>/dev/null
	/usr/sbin/hdparm --user-master u --security-erase UHouston /dev/${CLIENTDISK} &>/dev/null
	fi
	
	if [[ $CLIENTDISK =~ $NVME_REGEX ]]; then
	SECERASEFAIL=0
	/usr/sbin/nvme format /dev/${CLIENTDISK} --ses=1 --namespace-id=1 &>/dev/null
	/usr/sbin/nvme format /dev/${CLIENTDISK} --ses=2 --namespace-id=1 &>/dev/null
	fi
	
	if [[ $CLIENTDISK =~ $SCSI_REGEX ]]; then
	SECERASEFAIL=1
	fi
}



function default {
	clear
	echo ""
	echo "UIT-TSS-SHRED running in default mode."
	echo ""
	
	echo ""
	echo "[1/3] Writing a stream of random characters to half of ${CLIENTDISK}...."
	sleep 1
	randhalf
	
	echo ""
	echo "[2/3] Using Secure Erase on ${CLIENTDISK}. This can take a while, please keep the device powered on...."
	sleep 1
	secerase
	if [[ $SECERASEFAIL=='1' ]]; then
	echo "No compatible SATA or NVME drive is detected. Continuing...."
	fi

	echo ""
	echo "[3/3] Verifying - searching sectors on ${CLIENTDISK} for non-${VRFYCHAR} bits...."
	VRFYCHAR='0'
	vrfymedium
	
	if [[ $VRFYFAIL=='1' ]]; then
	echo ""
	echo ""
	echo ""
	echo "[1/2] Verification failed, Zeroing disk ${CLIENTDISK}"
	zerofull
	
	echo ""
	echo "[2/2] Verifying - searching sectors on ${CLIENTDISK} for non-${VRFYCHAR} bits...."
	vrfymedium
	fi
}



function zero {
	clear
	echo ""
	echo "UIT-TSS-SHRED running in zero mode."
	echo ""

	echo ""
	echo "[1/2] Using the Write Zero method on ${CLIENTDISK}...."
	sleep 1
	zerofull
	
	echo ""
	echo "[2/2] Verifying - searching sectors on ${CLIENTDISK} for non-${VRFYCHAR} bits...."
	sleep 1
	VRFYCHAR='0'
	vrfyfast
}



function dod {
	randbit
	
	clear
	echo ""
	echo "UIT-TSS-SHRED running in DOD 5220.22-M mode."
	echo ""

	echo ""
	echo "[1/6] Writing a pass of 0's to ${CLIENTDISK}"
	zerofull
	
	echo ""
	echo "[2/6] Verifying disk ${CLIENTDISK} - checking for 0's...."
	VRFYCHAR='0'
	vrfyfull

	echo ""
	echo "[3/6] Writing a pass of 1's to ${CLIENTDISK}"
	SELBIT='1'
	charfull
	
	echo ""
	echo "[4/6] Verifying disk ${CLIENTDISK} - checking for 1's...."
	VRFYCHAR='1'
	vrfyfull

	echo ""
	echo "[5/6] Writing a pass of a random bit (${RANDOMBIT}) to ${CLIENTDISK}"
	SELBIT=${RANDBIT}
	charfull
	
	echo ""
	echo "[6/6] Verifying disk ${CLIENTDISK} - checking for the random bit (${RANDOMBIT})...."
	VRFYCHAR=${RANDBIT}
	vrfyfull
}



function rcmp {
	randbit

	clear
	echo ""
	echo "UIT-TSS-SHRED running in RCMP TSSIT OPS-II mode."
	echo ""

	echo ""
	echo "[1/8] Writing a pass of 0's to ${CLIENTDISK}"
	zerofull

	echo ""
	echo "[2/8] Writing a pass of 1's to ${CLIENTDISK}"
	SELCHAR='1'
	charfull

	echo ""
	echo "[3/8] Writing a pass of 0's to ${CLIENTDISK}"
	zerofull

	echo ""
	echo "[4/8] Writing a pass of 1's to ${CLIENTDISK}"
	SELCHAR='1'
	charfull

	echo ""
	echo "[5/8] Writing a pass of 0's to ${CLIENTDISK}"
	zerofull

	echo ""
	echo "[6/8] Writing a pass of 1's to ${CLIENTDISK}"
	SELCHAR='1'
	charfull

	echo ""
	echo "[7/8] Writing a pass of a random bit (${RANDOMBIT}) to ${CLIENTDISK}"
	SELCHAR=${RANDBIT}
	charfull
	
	echo ""
	echo "[8/8] Verifying disk - checking ${CLIENTDISK} for the random bit (${RANDOMBIT})'s...."
	VRFYCHAR=${RANDBIT}
	vrfyfull
}



function schneier {
	clear
	echo ""
	echo "UIT-TSS-SHRED running in Schneier mode."
	echo ""

	echo ""
	echo "[1/7] Writing a pass of 1's to ${CLIENTDISK}"
	SELCHAR='1'
	charfull

	echo ""
	echo "[2/7] Writing a pass of 0's to ${CLIENTDISK}"
	zerofull

	echo ""
	echo "[3/7] Writing a stream of random characters to ${CLIENTDISK}."
	randfull

	echo ""
	echo "[4/7] Writing a stream of random characters to ${CLIENTDISK}."
	randfull

	echo ""
	echo "[5/7] Writing a stream of random characters to ${CLIENTDISK}."
	randfull

	echo ""
	echo "[6/7] Writing a stream of random characters to ${CLIENTDISK}."
	randfull

	echo ""
	echo "[7/7] Writing a stream of random characters to ${CLIENTDISK}."
	randfull

	echo ""
	echo ""
	echo "The drive ${CLIENTDISK} is erased using Schneier's method."
}



function gutmann {
	clear
	echo ""
	echo "UIT-TSS-SHRED running in Gutmann mode."
	echo ""

	echo ""
	echo "[1/35] Writing a pass of a random bit (${RANDOMBIT1}) to ${CLIENTDISK}"
	randbit
	SELCHAR=${RANDBIT}
	charfull

	echo "[2/35] Writing a pass of a random bit (${RANDOMBIT2}) to ${CLIENTDISK}"
	randbit
	SELCHAR=${RANDBIT}
	charfull

	echo "[3/35] Writing a pass of a random bit (${RANDOMBIT3}) to ${CLIENTDISK}"
	randbit
	SELCHAR=${RANDBIT}
	charfull

	echo "[4/35] Writing a pass of a random bit (${RANDOMBIT4}) to ${CLIENTDISK}"
	randbit
	SELCHAR=${RANDBIT}
	charfull

	echo "[5/35] Writing pattern 01010101 to ${CLIENTDISK}"
	SELCHAR='01010101'
	charfull

	echo "[6/35] Writing pattern 10101010 to ${CLIENTDISK}"
	SELCHAR='10101010'
	charfull

	echo "[7/35] Writing pattern 10010010 to ${CLIENTDISK}"
	SELCHAR='10010010'
	charfull

	echo "[8/35] Writing pattern 01001001 to ${CLIENTDISK}"
	SELCHAR='01001001'
	charfull

	echo "[9/35] Writing pattern 00100100 to ${CLIENTDISK}"
	SELCHAR='00100100'
	charfull

	echo "[10/35] Writing pattern 00000000 to ${CLIENTDISK}"
	SELCHAR='00000000'
	charfull

	echo "[11/35] Writing pattern 00010001 to ${CLIENTDISK}"
	SELCHAR='00010001'
	charfull

	echo "[12/35] Writing pattern 00100010 to ${CLIENTDISK}"
	SELCHAR='00100010'
	charfull

	echo "[13/35] Writing pattern 00110011 to ${CLIENTDISK}"
	/usr/bin/yes "00110011" | (pv > /dev/${CLIENTDISK})

	echo "[14/35] Writing pattern 01000100 to ${CLIENTDISK}"
	/usr/bin/yes "01000100" | (pv > /dev/${CLIENTDISK})

	echo "[15/35] Writing pattern 01010101 to ${CLIENTDISK}"
	/usr/bin/yes "01010101" | (pv > /dev/${CLIENTDISK})

	echo "[16/35] Writing pattern 01100110 to ${CLIENTDISK}"
	/usr/bin/yes "01100110" | (pv > /dev/${CLIENTDISK})

	echo "[17/35] Writing pattern 01110111 to ${CLIENTDISK}"
	/usr/bin/yes "01110111" | (pv > /dev/${CLIENTDISK})

	echo "[18/35] Writing pattern 10001000 to ${CLIENTDISK}"
	/usr/bin/yes "10001000" | (pv > /dev/${CLIENTDISK})

	echo "[19/35] Writing pattern 10011001 to ${CLIENTDISK}"
	/usr/bin/yes "10011001" | (pv > /dev/${CLIENTDISK})

	echo "[20/35] Writing pattern 10101010 to ${CLIENTDISK}"
	/usr/bin/yes "10101010" | (pv > /dev/${CLIENTDISK})

	echo "[21/35] Writing pattern 10111011 to ${CLIENTDISK}"
	/usr/bin/yes "10111011" | (pv > /dev/${CLIENTDISK})

	echo "[22/35] Writing pattern 11001100 to ${CLIENTDISK}"
	/usr/bin/yes "11001100" | (pv > /dev/${CLIENTDISK})

	echo "[23/35] Writing pattern 11011101 to ${CLIENTDISK}"
	/usr/bin/yes "11011101" | (pv > /dev/${CLIENTDISK})

	echo "[24/35] Writing pattern 11101110 to ${CLIENTDISK}"
	/usr/bin/yes "11101110" | (pv > /dev/${CLIENTDISK})

	echo "[25/35] Writing pattern 11111111 to ${CLIENTDISK}"
	/usr/bin/yes "11111111" | (pv > /dev/${CLIENTDISK})

	echo "[26/35] Writing pattern 10010010 to ${CLIENTDISK}"
	/usr/bin/yes "10010010" | (pv > /dev/${CLIENTDISK})

	echo "[27/35] Writing pattern 01001001 to ${CLIENTDISK}"
	/usr/bin/yes "01001001" | (pv > /dev/${CLIENTDISK})

	echo "[28/35] Writing pattern 00100100 to ${CLIENTDISK}"
	/usr/bin/yes "00100100" | (pv > /dev/${CLIENTDISK})

	echo "[29/35] Writing pattern 01101101 to ${CLIENTDISK}"
	/usr/bin/yes "01101101" | (pv > /dev/${CLIENTDISK})

	echo "[30/35] Writing pattern 10110110 to ${CLIENTDISK}"
	/usr/bin/yes "10110110" | (pv > /dev/${CLIENTDISK})

	echo "[31/35] Writing pattern 11011011 to ${CLIENTDISK}"
	/usr/bin/yes "11011011" | (pv > /dev/${CLIENTDISK})

	echo "[32/35] Writing a pass of a random bit (${RANDOMBIT5}) to ${CLIENTDISK}"
	/usr/bin/yes "${RANDOMBIT5}" | (pv > /dev/${CLIENTDISK})

	echo "[33/35] Writing a pass of a random bit (${RANDOMBIT6}) to ${CLIENTDISK}"
	/usr/bin/yes "${RANDOMBIT6}" | (pv > /dev/${CLIENTDISK})

	echo "[34/35] Writing a pass of a random bit (${RANDOMBIT7}) to ${CLIENTDISK}"
	/usr/bin/yes "${RANDOMBIT7}" | (pv > /dev/${CLIENTDISK})

	echo "[35/35] Writing a pass of a random bit (${RANDOMBIT8}) to ${CLIENTDISK}"
	/usr/bin/yes "${RANDOMBIT8}" | (pv > /dev/${CLIENTDISK})

	echo ""
	echo ""
	echo "The drive ${CLIENTDISK} is erased using Gutmann's method."
}



function verify {
	clear
	echo ""
	echo "UIT-TSS-SHRED running in Verify Mode."
	echo ""
	
	echo ""
	echo "Which level of verification do you want?"
	echo ""
	echo ""
	echo "1 Full verification (Default)
	-Longest, verifies every bit on the disk"
	echo ""
	echo "2 Very fast verification
	-10 divisions, 5GB verified"
	echo ""
	echo "3 Medium verification
	-10 divisions, 20GB verified"
	echo ""
	echo "4 Other (Manual Specification)"
	echo ""
	read -n 1 -p "Select mode [1-4]: " VRFYSELECT
	echo ""
	case $VRFYSELECT in
	1)
	VRFYMODE='full'
	;;
	2)
	VRFYMODE='fast'
	;;
	3)
	VRFYMODE='medium'
	;;
	4)
	VRFYMODE='custom'
	;;
	*)
	echo ""
	echo ""
	echo "Incorrect input selected, please try again"
	sleep 1
	verify
	;;
	esac
}


function execute {
	start_time=$SECONDS
	
	if [[ $MODE == 'default' ]]; then
	default
	fi

	if [[ $MODE == 'zero' ]]; then
	zero
	fi

	if [[ $MODE == 'secureerase' ]]; then
	secureerase
	fi

	if [[ $MODE == 'dod' ]]; then
	dod
	fi

	if [[ $MODE == 'rcmp' ]]; then
	rcmp
	fi
	
	if [[ $MODE == 'gutmann' ]]; then
	gutmann
	fi
	
	if [[ $MODE == 'schneier' ]]; then
	schneier
	fi
	
	if [[ $MODE == 'verify' ]]; then
	echo -n ""
	fi
}



function terminate {
	elapsed=$(( SECONDS - start_time ))
	TIME=$(eval "echo $(date -ud "@$elapsed" +'$((%s/3600/24)) days %H hours and %M minutes')")
	echo ""
	echo ""
	echo "--------------------"
	echo ""
	/usr/bin/play /root/oven.mp3 &> /dev/null
	echo "Process has finished in ${TIME}."
	read -p "Press Enter to shutdown..."
	poweroff
}



intro
modeselect
diskselect
execute
terminate
EOF

(cd /opt/UIT-TSS-SHRED && \
	lb build)
