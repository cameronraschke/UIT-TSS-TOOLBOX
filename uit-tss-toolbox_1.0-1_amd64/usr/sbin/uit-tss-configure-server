#!/bin/bash

INTERFACES=$(cat /proc/net/dev | grep -oP '.*:\ ' | sed 's/://g' | sed 's/[[:space:]]//g')
LANIP='10.0.0.1'
LANSUBNET='24'

function initialize {
    clear
    echo ""
    echo "Initializing UIT-TSS-CONFIGURE-SERVER by Cameron Raschke"
    echo ""

    read -p "Press Enter to continue...."

    echo ""
    echo "Setting all interfaces down"
    for i in $INTERFACES; do
    ip link set down $i
    done

    echo ""
    echo "Flushing all IP addresses"
    for i in $INTERFACES; do
    ip addr flush dev $i
    done

    echo ""
    echo "Removing all interfaces from bonds and bridges"
    for i in $INTERFACES; do
    ip link set dev $i nomaster
    done

    echo ""
    echo "Flushing all routes"
    ip route flush table main
}

function intro {
	clear
	echo ""
	echo "Welcome to UIT-TSS-CONFIGURE-SERVER by Cameron Raschke."
	echo ""
	echo "Press CTRL + C at any time to exit"
	echo ""
	echo ""
	echo ""
	echo "| |    | |  | |     | |"
	echo "| |    | |  | |_____| |"
	echo "| |    | |  | |_____| |"
	echo "| |____| |  | |     | |"
	echo "\________/  | |     | |"
	echo ""
	echo "------------------------------"
	echo ""
    echo "Checklist:
	-Physical connections
	   * Make sure the server has power and ethernet attached.
       * Make sure the server has two interfaces connected - one for WAN, one for LAN.
	-Storage
	   * Make sure the server has over 100GB of free storage on the root drive.
    -Data
       * Backup the images to the server once it has been configured."
	read -p "Press Enter to continue...."
	clear
}

function ifselect {
    echo "Which interface is your WAN port?"
    echo $INTERFACES

    echo "Which interface is your LAN port?"
    echo $INTERFACES
}

function ifconf {
    echo "Configuring networking"
}

funciton firewall {
cat <<'EOF' > /root/firewall.sh
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

iptables -t filter -A INPUT -i lo -j ACCEPT
iptables -t filter -A FORWARD -i lo -j ACCEPT
iptables -t filter -A FORWARD -o lo -j ACCEPT
iptables -t filter -A OUTPUT -o lo -j ACCEPT

iptables -t filter -A INPUT -i $LANIF -j ACCEPT
iptables -t filter -A OUTPUT -o $LANIF -j ACCEPT

iptables -t filter -A INPUT -i $WANIF -p udp --sport 53 -j ACCEPT
iptables -t filter -A INPUT -i $WANIF -p tcp --sport 80 -j ACCEPT
iptables -t filter -A INPUT -i $WANIF -p tcp --sport 443 -j ACCEPT
iptables -t filter -A INPUT -i $WANIF -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -t filter -A INPUT -i $WANIF -j DROP

iptables -t filter -A OUTPUT -o $WANIF -p udp --dport 53 -j ACCEPT
iptables -t filter -A OUTPUT -o $WANIF -p tcp --dport 80 -j ACCEPT
iptables -t filter -A OUTPUT -o $WANIF -p tcp --dport 443 -j ACCEPT
iptables -t filter -A OUTPUT -o $WANIF -j DROP

EOF

    chown root:root /root/firewall.sh
    chmod 700 /root/firewall.sh
    /root/firewall.sh
}

function unixaccounts {
    echo -e 'UHouston!\nUHouston!\n' | passwd root
    echo -e 'UHouston!\nUHouston!\n' | passwd cameron

}

function hostname {
    hostnamectl set-hostname UIT-TSS-LAPTOP-SERVER
}

function crontab {
    echo -n "@reboot /root/firewall.sh" > /etc/cron.d/00-firewall
}

function pkginstall {
    echo "Updating and upgrading all packages...."
    apt update -y
    apt upgrade -y
    echo "Installing necessary packages...."
    apt install dnsmasq samba iftop iotop iptables chpasswd -y
    echo "Enabling new packages...."
    systemctl enable nmbd smbd dnsmasq
    systemctl stop dnsmasq
}

function pkgconf {
    echo "Configuring Samba...."
cat <<'EOF' > /etc/samba/smb.conf
[global]
workgroup = WORKGROUP
server string = Samba Server
interfaces = ${LANIP}/${LANSUBNET} ${LANIF}
socket address = ${LANIP}
bind interfaces only = yes
log file = /var/log/samba/log.%m
max log size = 50
logging = file
panic action = /usr/share/samba/panic-action %d
server role = standalone server
obey pam restrictions = yes
unix password sync = yes
passwd program = /usr/bin/passwd %u
passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .
pam password change = yes
map to guest = bad user
usershare allow guests = no

[dell]
path = /home/dell
read only = no
browsable = yes

[hp]
path = /home/hp
read only = no
browsable = yes

[desktops]
path = /home/desktops
read only = no
browsable = yes
EOF

    echo -e 'UHouston!\nUHouston!\n' | smbpasswd -a cameron

    mkdir /home/dell
    mkdir /home/desktops
    mkdir /home/hp

    chown cameron:cameron /home/dell -R
    chown cameron:cameron /home/desktops -R
    chown cameron:cameron /home/hp -R

    echo "Configuring SSH...."
    sed -i 's/#ListenAddress 0.0.0.0/ListenAddress 10.0.0.1/g' /etc/ssh/sshd_config
    sed -i 's/#AddressFamily any/AddressFamily inet/g' /etc/ssh/sshd_config

    echo "Configuring dnsmasq...."
cat <<'EOF' > /etc/dnsmasq.conf
port=53
no-resolv
listen-address=${LANIP}
bogus-priv
strict-order
interface=${LANIF}
bind-interfaces

dhcp-option=1,255.255.255.0
dhcp-option=6,10.0.0.1
dhcp-option=15,.uit
dhcp-range=10.0.0.5,10.0.0.254,255.255.255.0,2m
dhcp-sequential-ip
EOF   

apt autoremove -y
}

function pkgrestart {
    echo "Applying all package changes...."
    systemctl restart nmbd smbd ssh dnsmasq
}

function writescripts {
echo "Creating SMB Status script"
echo "watch -n 0.5 'smbstatus --verbose'" > /root/smbstatus.sh
chown root:root /root/smbstatus.sh
chmod 700 /root/smbstatus.sh
}

function kubernetes {
    CTRNAME='uit-tss-laptop-server'

    swapoff -a
    apt install containerd -y
    apt install ipvsadm -y
    curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
    echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] \
        https://apt.kubernetes.io/ kubernetes-xenial main" \
        | sudo tee /etc/apt/sources.list.d/kubernetes.list
    apt update -y
    apt install -y kubelet kubeadm kubectl
    apt-mark hold kubelet kubeadm kubectl

    kubectl drain ${K8SNODE} --delete-emptydir-data --force --ignore-daemonsets

    kubeadm reset

    rm -r $HOME/.kube/

    iptables -F && iptables -t nat -F && iptables -t mangle -F && iptables -X
    iptables-legacy -F && iptables-legacy -t nat -F && iptables-legacy -t mangle -F && iptables-legacy -X

    ipvsadm --clear

    kubectl delete node ${K8SNODE}

    kubeadm init \
        --control-plane-endpoint ${LANIP} \
        --pod-network-cidr 192.168.1.1/24 \
        --apiserver-advertise-address=${LANIP} \
        --node-name ${K8SNODE}

        kubeadm init \
        --control-plane-endpoint 10.0.0.2 \
        --pod-network-cidr 192.168.1.1/24 \
        --apiserver-advertise-address=10.0.0.2 \
        --node-name uit-tss-laptop-server

        #kubeadm join 10.0.0.2:6443 --token 8goh09.6qoe3ov0eyqxhsvx \
        #--discovery-token-ca-cert-hash sha256:3f9b1d7bd8b91e41f8fe6fa1e8a486b979dee804df22e408875295ce48979cab 

    mkdir -p $HOME/.kube
    sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
    sudo chown $(id -u):$(id -g) $HOME/.kube/config

    export KUBECONFIG=/etc/kubernetes/admin.conf

    mkdir /root/k8s

    #https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml

cat <<'EOF' > /root/k8s/flannel.yml
---
kind: Namespace
apiVersion: v1
metadata:
  name: kube-flannel
  labels:
    pod-security.kubernetes.io/enforce: privileged
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: flannel
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - nodes/status
  verbs:
  - patch
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: flannel
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: flannel
subjects:
- kind: ServiceAccount
  name: flannel
  namespace: kube-flannel
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: flannel
  namespace: kube-flannel
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: kube-flannel-cfg
  namespace: kube-flannel
  labels:
    tier: node
    app: flannel
data:
  cni-conf.json: |
    {
      "name": "cbr0",
      "cniVersion": "0.3.1",
      "plugins": [
        {
          "type": "flannel",
          "delegate": {
            "hairpinMode": true,
            "isDefaultGateway": true
          }
        },
        {
          "type": "portmap",
          "capabilities": {
            "portMappings": true
          }
        }
      ]
    }
  net-conf.json: |
    {
      "Network": "192.168.1.0/24",
      "Backend": {
        "Type": "vxlan"
      }
    }
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-flannel-ds
  namespace: kube-flannel
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/os
                operator: In
                values:
                - linux
      hostNetwork: true
      priorityClassName: system-node-critical
      tolerations:
      - operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      - name: install-cni-plugin
       #image: flannelcni/flannel-cni-plugin:v1.1.0 for ppc64le and mips64le (dockerhub limitations may apply)
        image: docker.io/rancher/mirrored-flannelcni-flannel-cni-plugin:v1.1.0
        command:
        - cp
        args:
        - -f
        - /flannel
        - /opt/cni/bin/flannel
        volumeMounts:
        - name: cni-plugin
          mountPath: /opt/cni/bin
      - name: install-cni
       #image: flannelcni/flannel:v0.20.0 for ppc64le and mips64le (dockerhub limitations may apply)
        image: docker.io/rancher/mirrored-flannelcni-flannel:v0.20.0
        command:
        - cp
        args:
        - -f
        - /etc/kube-flannel/cni-conf.json
        - /etc/cni/net.d/10-flannel.conflist
        volumeMounts:
        - name: cni
          mountPath: /etc/cni/net.d
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
      containers:
      - name: kube-flannel
       #image: flannelcni/flannel:v0.20.0 for ppc64le and mips64le (dockerhub limitations may apply)
        image: docker.io/rancher/mirrored-flannelcni-flannel:v0.20.0
        command:
        - /opt/bin/flanneld
        args:
        - --ip-masq
        - --kube-subnet-mgr
        resources:
          requests:
            cpu: "100m"
            memory: "50Mi"
          limits:
            cpu: "100m"
            memory: "50Mi"
        securityContext:
          privileged: false
          capabilities:
            add: ["NET_ADMIN", "NET_RAW"]
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: EVENT_QUEUE_DEPTH
          value: "5000"
        volumeMounts:
        - name: run
          mountPath: /run/flannel
        - name: flannel-cfg
          mountPath: /etc/kube-flannel/
        - name: xtables-lock
          mountPath: /run/xtables.lock
      volumes:
      - name: run
        hostPath:
          path: /run/flannel
      - name: cni-plugin
        hostPath:
          path: /opt/cni/bin
      - name: cni
        hostPath:
          path: /etc/cni/net.d
      - name: flannel-cfg
        configMap:
          name: kube-flannel-cfg
      - name: xtables-lock
        hostPath:
          path: /run/xtables.lock
          type: FileOrCreate
EOF
    kubectl apply -f /root/k8s/flannel.yml

    kubectl taint nodes --all node-role.kubernetes.io/control-plane-    

cat <<'EOF' > /root/k8s/dev-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: development
  labels:
    name: development
EOF
kubectl create -f /root/k8s/dev-namespace.yaml

cat <<'EOF' > /root/k8s/prod-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    name: production
EOF
kubectl create -f /root/k8s/prod-namespace.yaml

cat <<'EOF' > /root/k8s/nginx-deployment-dev.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 4
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.16.1
        ports:
        - containerPort: 80
EOF
kubectl apply -f /root/k8s/nginx-deployment.yaml --namespace=development

cat <<'EOF' > /root/k8s/nginx-deployment-prod.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 4
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.16.1
        ports:
        - containerPort: 80
EOF
kubectl apply -f /root/k8s/nginx-deployment.yaml --namespace=production






}

function terminate {
    read -p "Press Enter to reboot...."
    reboot
}

